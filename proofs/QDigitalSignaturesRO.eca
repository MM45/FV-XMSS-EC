(**************************************************************************)
(* File containing everything related to (public-key/digital) signatures  *)
(* in the quantum setting (i.e., considering quantum adversaries)         *)
(* This file is based on the material from the following references:      *)
(* - "A Digital Signature Scheme Secure Against Adaptive                  *)
(*    Chosen-Message Attack"                                              *)
(*   DOI: 10.1137/0217017                                                 *)
(* - "Digital Signatures"                                                 *) 
(*   DOI: 10.1007/978-0-387-27712-7.                                      *)
(**************************************************************************)

(* --- Require/Import Theories --- *)
(* -- Built-in (i.e, standard library) -- *)
require import AllCore List.


(* -- Local -- *)
require QDigitalSignatures T_QROM.

(* Clone and inline QDigitalSignatures theory *)
clone include QDigitalSignatures.

(* 
  Clone and import T_QROM theory and rename it to RO. 
  Defines/declares a random oracle from type RO.from to RO.hash 
*)
clone import T_QROM as RO.


(* --- Stateless Signature Schemes With Access to Random Oracles --- *)
theory Stateless_RO.
  (* -- General -- *)
  (* Import theory for stateless signature schemes (from QDigitalSignatures) *)
  import Stateless.
  
  (* Module type for stateless signature schemes with access to a random oracle *)
  module type Scheme_RO(O : QRO) = {
    include Scheme
  }.
  
  
  (* -- Correctness -- *)
  (* Probabilistic program formalizing the correctness of stateless signature schemes *)
  module Correctness_RO(S : Scheme_RO, O : QRO_i) = {
    proc main(m : msg_t) : bool = {
      var is_valid : bool;
      
      O.init();
      
      is_valid <@ Correctness(S(O)).main(m); 
      
      return is_valid;
    }
  }.
  
  
  (*
    -- 
    Key-Only Attack (KOA).
    Attacks in which the adversary is only given the public/verification key
    -- 
  *)
  (*
    - 
    Total Break under Key-Only Attack (TB-KOA). 
    Given the public/verification key, the adversary is tasked with computing the
    corresponding secret key
    -
  *)
  (* Class of adversaries against TB-KOA *)
  quantum module type Adv_TBKOA_RO(O : QRO) = {
    include Adv_TBKOA
  }.
  
  (* TB-KOA game *)
  module TB_KOA_RO(S : Scheme_RO, A : Adv_TBKOA_RO, O : QRO_i) = {
    proc main() : bool = {
      var is_break : bool;
      
      O.init();
      
      is_break <@ TB_KOA(S(O), A(O)).main();
      
      return is_break;
    }
  }.
  
  
  (* 
    - 
    Universal Forgery under Key-Only Attack (UF-KOA).
    Given the public/verification key and an arbitrary message, the adversary is tasked 
    with forging a signature for the given message
    - 
  *)
  (* Class of adversaries against UF-KOA *)
  quantum module type Adv_UFKOA_RO(O : QRO) = {
    include Adv_UFKOA
  }.
  
  (* UF-KOA game *)
  module UF_KOA_RO(S : Scheme_RO, A : Adv_UFKOA_RO, O : QRO_i) = {
    proc main() : bool = {
      var is_valid : bool;
      
      O.init();
      
      is_valid <@ UF_KOA(S(O), A(O)).main();
      
      return is_valid;
    }
  }.

  
  (*
    - 
    Selective Forgery under Key-Only Attack (SF-KOA).
    After picking a message, the adversary is given the public/verification key and tasked
    with forging a signature for the picked message
    -
  *)
  (* Class of adversaries against SF-KOA *)
  quantum module type Adv_SFKOA_RO(O : QRO) = {
    include Adv_SFKOA
  }.

  (* SF-KOA game *)
  module SF_KOA_RO(S : Scheme_RO, A : Adv_SFKOA_RO, O : QRO_i) = {
    proc main() : bool = {
      var is_valid : bool;

      O.init();
      
      is_valid <@ SF_KOA(S(O), A(O)).main();

      return is_valid;
    }
  }.

  
  (*
    -
    Existential Forgery under Key-Only Attack (EF-KOA).
    Given the public/verification key, the adversary is tasked with forging a signature
    for any fresh message
    -
  *)
  (* Class of adversaries against EF-KOA *)
  quantum module type Adv_EFKOA_RO(O : QRO) = {
    proc forge(pk : pk_t) : msg_t * sig_t 
  }.

  (* EF-KOA game *)
  module EF_KOA_RO(S : Scheme_RO, A : Adv_EFKOA_RO, O : QRO_i) = {
    proc main() : bool = {
      var is_valid: bool;

      O.init();
      
      is_valid <@ EF_KOA(S(O), A(O)).main();

      return is_valid;
    }
  }.


  (* 
    -- 
    Random-Message Attack (RMA).
    Attacks in which the adversary is given the public/verification key as well as 
    the signatures for a set of random messages *known* to it, but not *chosen* by it
    -- 
  *)
  (* 
    - 
    Total Break under Random-Message Attack (TB-RMA). 
    Given the public/verification key and the signatures for a set of known random messages, 
    the adversary is tasked with computing the secret key corresponding to the 
    public/verification key
    -
  *)
  (* Class of adversaries against TB-RMA *)
  quantum module type Adv_TBRMA_RO(O : QRO) = {
    include Adv_TBRMA 
  }.
  
  (* TB-RMA game *)
  module TB_RMA_RO(S : Scheme_RO, A : Adv_TBRMA_RO, O : QRO_i) = {
    proc main() : bool = {
      var is_break : bool;
      
      O.init();
      
      is_break <@ TB_RMA(S(O), A(O)).main(); 
      
      return is_break;
    }
  }.
  
  
  (* 
    - 
    Universal Forgery under Random-Message Attack (UF-RMA).
    Given the public/verification key, the signatures for a set of known random messages, 
    and an arbitrary message, the adversary is tasked with forging a signature for 
    the given (latter) message
    -
  *)
  (* Class of adversaries against UF-RMA *)
  quantum module type Adv_UFRMA_RO(O : QRO) = {
    include Adv_UFRMA
  }.
  
  (* UF-RMA game *)
  module UF_RMA_RO(S : Scheme_RO, A : Adv_UFRMA_RO, O : QRO_i) = {
    proc main() : bool = {
      var is_validfresh : bool;
      
      O.init();
      
      is_validfresh <@ UF_RMA(S(O), A(O)).main();
      
      return is_validfresh;
    }
  }.
  

  (*
    -
    Selective Forgery under Random-Message Attack (SF-RMA).
    After picking a message, the adversary is given the public/verification key, 
    the signatures for a set of known random messages, and an arbitrary message, and is tasked
    with forging a signature for the picked message
    -
  *)
  (* Class of adversaries against SF-RMA *)
  quantum module type Adv_SFRMA_RO(O : QRO) = {
    include Adv_SFRMA
  }.

  (* SF-RMA game *)
  module SF_RMA_RO(S : Scheme_RO, A : Adv_SFRMA_RO, O : QRO_i) = {
    proc main() : bool = {
      var is_validfresh : bool;

      O.init();
      
      is_validfresh <@ SF_RMA(S(O), A(O)).main();
      
      return is_validfresh;
    }
  }.

  
  (*
    -
    Existential Forgery under Random-Message Attack (EF-RMA)
    Given the public/verification key and the signatures for a set of known random messages,
    the adversary is tasked with forging a signature for any fresh message
    -
  *)
  (* Class of adversaries against EF-RMA *)
  quantum module type Adv_EFRMA_RO(O : QRO) = {
    include Adv_EFRMA
  }.

  module EF_RMA_RO(S : Scheme_RO, A : Adv_EFRMA_RO, O : QRO_i) = {   
    proc main() : bool = {
      var is_validfresh : bool;
      
      O.init();
      
      is_validfresh <@ EF_RMA(S(O), A(O)).main();
      
      return is_validfresh;
    }
  }.
  
    (* Class of adversaries against EF-RMA *)
  quantum module type Adv_I_EFRMA_RO (O : QRO, SO : SOracle_RMA) = {
      proc forge(pk : pk_t) : msg_t * sig_t
  }.
  
  (* I_EF-RMA game *)
  module I_EF_RMA_RO(S : Scheme_RO, A : Adv_I_EFRMA_RO, SO: Oracle_RMA, O : QRO_i) = { 
    proc main() : bool = {
    var is_validfresh : bool;
    
    O.init();
    
    is_validfresh <@ I_EF_RMA(S(O), A(O), SO).main();
    
    return is_validfresh;
    }
  }.  

  (*
    -- 
    Generic Chosen-Message Attack (GCMA).
    Attacks in which the adversary is given the public/verification key as well as
    the signatures for a set of *chosen* messages. Here, all messages are chosen
    (1) non-adaptively; that is, before obtaining any of the signatures, and
    (2) independently of the public key; that is, without knowing the public key
        at the time of choosing the messages
    --
  *)
  (* 
    - 
    Total Break under Generic Chosen-Message Attack (TB-GCMA). 
    Given the public/verification key and the signatures for a set of messages chosen
    non-adaptively and indepedently of the public key, the adversary is tasked with 
    computing the secret key corresponding to the public/verification key
    -
  *)
  (* Class of adversaries against TB-GCMA *)
  quantum module type Adv_TBGCMA_RO(O : QRO) = {
    include Adv_TBGCMA
  }.
  
  (* TB-GCMA game *)
  module TB_GCMA_RO(S : Scheme_RO, A : Adv_TBGCMA_RO, O : QRO_i) = {
    proc main() : bool = {
      var is_break : bool;
      
      O.init();
      
      is_break <@ TB_GCMA(S(O), A(O)).main(); 
      
      return is_break; 
    }
  }.
  
  
  (*
    - 
    Universal Forgery under Generic Chosen-Message Attack (UF-GCMA).
    Given the public/verification key, the signatures for a set of messages chosen
    non-adaptively and indepedently of the public key, and an arbitrary message, 
    the adversary is tasked with forging a signature for the given (latter) message
    -
  *)
  (* Class of adversaries against UF-GCMA *)
  quantum module type Adv_UFGCMA_RO(O : QRO) = {
    include Adv_UFGCMA
  }.

  (* UF-GCMA game *)
  module UF_GCMA_RO(S : Scheme_RO, A : Adv_UFGCMA_RO, O : QRO_i) = {
    proc main() : bool = {
      var is_validfresh : bool;
      
      O.init();
      
      is_validfresh <@ UF_GCMA(S(O), A(O)).main();
      
      return is_validfresh;
    }
  }.

  
  (* 
    - 
    Selective Forgery under Generic Chosen-Message Attack (SF-GCMA).
    After picking a message, the adversary is given the public/verification key and
    the signatures for a set of messages chosen non-adaptively and indepedently 
    of the public key, and is tasked with forging a signature for the picked message
    -
  *)
  (* Class of adversaries against SF-GCMA *)
  quantum module type Adv_SFGCMA_RO(O : QRO) = {
    proc pick() : msg_t
    proc choose() : msg_t list
    proc forge(pk : pk_t, sigl : sig_t list) : sig_t
  }.

  (* SF-GCMA game *)
  module SF_GCMA_RO(S : Scheme_RO, A : Adv_SFGCMA_RO, O : QRO_i) = {
    proc main() : bool = {
      var is_validfresh : bool;
      
      O.init();
      
      is_validfresh <@ SF_GCMA(S(O), A(O)).main();
      
      return is_validfresh; 
    }
  }.

  
  (*
    -
    Existential Forgery under Generic Chosen-Message Attack (EF-GCMA)
    Given the public/verification key and the signatures for a set of messages 
    chosen non-adaptively and indepedently of the public key, the adversary is tasked 
    with forging a signature for any fresh message
    -
  *)
  (* Class of adversaries against EF-GCMA *)
  quantum module type Adv_EFGCMA_RO(O : QRO) = {
    include Adv_EFGCMA
  }.
  
  (* EF-GCMA game *)
  module EF_GCMA_RO(S : Scheme_RO, A : Adv_EFGCMA_RO, O : QRO_i) = {   
    proc main() : bool = {
      var is_validfresh : bool;
      
      O.init();
      
      is_validfresh <@ EF_GCMA(S(O), A(O)).main();
      
      return is_validfresh;  
    }  
  }.  

  
  (*
    -- 
    Non-Adaptive Chosen-Message Attack (NACMA)/Directed Chosen-Message Attack (DCMA).
    Attacks in which the adversary is given the public/verification key as well as
    the signatures for a set of *chosen* messages. Here, all messages are chosen
    non-adaptively; that is, before obtaining any of the signatures. However, the chosen
    messages may depend on the public key; i.e., the adversary is given the public key
    when asked to provide the messages
    --
  *)
  (* 
    - 
    Total Break under Non-Adaptive Chosen-Message Attack (TB-NACMA). 
    Given the public/verification key and the signatures for a set of non-adaptively
    chosen messages, the adversary is tasked with computing the secret key 
    corresponding to the public/verification key
    -
  *)
  (* Class of adversaries against TB-NACMA *)
  quantum module type Adv_TBNACMA_RO(O : QRO) = {
    include Adv_TBNACMA
  }.
  
  (* TB-NACMA game *)
  module TB_NACMA_RO(S : Scheme_RO, A : Adv_TBNACMA_RO, O : QRO_i) = {
    proc main() : bool = {
      var is_break : bool;
      
      O.init();
      
      is_break <@ TB_NACMA(S(O), A(O)).main();
      
      return is_break; 
    }
  }.
  
  
  (*
    - 
    Universal Forgery under Non-Adaptive Chosen-Message Attack (UF-NACMA).
    Given the public/verification key, the signatures for a set of non-adaptively
    chosen messages, and an arbitrary message, the adversary is tasked with forging 
    a signature for the given (latter) message
    -
  *)
  (* Class of adversaries against UF-NACMA *)
  quantum module type Adv_UFNACMA_RO(O : QRO) = {
    include Adv_UFNACMA
  }.

  (* UF-NACMA game *)
  module UF_NACMA_RO(S : Scheme_RO, A : Adv_UFNACMA_RO, O : QRO_i) = {
    proc main() : bool = {
      var is_validfresh : bool;
      
      O.init();
      
      is_validfresh <@ UF_NACMA(S(O), A(O)).main();
      
      return is_validfresh; 
    }
  }.

  
  (* 
    - 
    Selective Forgery under Non-Adaptive Chosen-Message Attack (SF-NACMA).
    After picking a message, the adversary is given the public/verification key and
    the signatures for a set of non-adaptively chosen messages, and is tasked with 
    forging a signature for the picked message
    -
  *)
  (* Class of adversaries against SF-NACMA *)
  quantum module type Adv_SFNACMA_RO(O : QRO) = {
    include Adv_SFNACMA
  }.

  (* SF-NACMA game *)
  module SF_NACMA_RO(S : Scheme_RO, A : Adv_SFNACMA_RO, O : QRO_i) = {
    proc main() : bool = {
      var is_validfresh : bool;
      
      O.init();
      
      is_validfresh <@ SF_NACMA(S(O), A(O)).main();
      
      return is_validfresh; 
    }
  }.

  
  (*
    -
    Existential Forgery under Non-Adaptive Chosen-Message Attack (EF-NACMA).
    Given the public/verification key and the signatures for a set of non-adaptively
    chosen messages the adversary is tasked with forging a signature for any fresh message
    -
  *)
  (* Class of adversaries against EF-NACMA *)
  quantum module type Adv_EFNACMA_RO(O : QRO) = {
    include Adv_EFNACMA
  }.
  
  (* EF-NACMA game *)
  module EF_NACMA_RO(S : Scheme_RO, A : Adv_EFNACMA_RO, O : QRO_i) = {   
    proc main() : bool = {
      var is_validfresh : bool;
      
      O.init();
      
      is_validfresh <@ EF_NACMA(S(O), A(O)).main();
      
      return is_validfresh; 
    }  
  }.  
  

  (*
    --
    (Adaptive) Chosen-Message Attack (CMA).
    Attacks in which the adversary is given the public/verification key as well as
    the signatures for a set of *chosen* messages. Here, all messages are chosen
    adaptively and may depend on the public key; that is, the adversary 
    (1) immediately receives a signature for a chosen message before choosing the 
        subsequent message, and
    (2) is given the public key when asked to provide the messages.
    --
  *)
  (*
  (* - General - *)
  (* Maximum number of oracle queries the adversary is allowed to make in TB-CMA game *)
  const q_tbcma : { int | 0 <= q_tbcma } as ge0_qtbcma.
  
  (* Maximum number of oracle queries the adversary is allowed to make in UF-CMA game *)
  const q_ufcma : { int | 0 <= q_ufcma } as ge0_qufcma.
  
  (* Maximum number of oracle queries the adversary is allowed to make in SF-CMA game *)
  const q_sfcma : { int | 0 <= q_sfcma } as ge0_qsfcma.
  
  (* Maximum number of oracle queries the adversary is allowed to make in EF-CMA game *)
  const q_efcma : { int | 0 <= q_efcma } as ge0_qefcma.
  
  (* Maximum number of oracle queries the adversary is allowed to make in SEF-CMA game *)
  const q_sefcma : { int | 0 <= q_sefcma } as ge0_qsefcma.
 
  (* 
    Type for signing oracles used in (adaptive) CMA game, including procedures 
    for initialization and auxiliary tasks 
  *)
  module type Oracle_CMA(S : Scheme) = {
    proc* init(sk_init : sk_t) : unit {}
    proc sign(m : msg_t) : sig_t { S.sign }
    proc fresh(m : msg_t) : bool {}
    proc nr_queries() : int {}
  }.

  (* 
    Type for signing oracles used in (adaptive) CMA games, only exposing the 
    procedure for signing 
  *)
  module type SOracle_CMA = {
    proc sign(m : msg_t) : sig_t
  }.
  
  (* 
    Default implementation of a signing oracle including procedures for 
    initialization and auxiliary tasks 
  *)
  module (O_CMA_Default : Oracle_CMA) (S : Scheme) = {
    var sk : sk_t
    var qs : msg_t list
    
    (* Initialize secret/signing key and oracle query list qs *)
    proc init(sk_init : sk_t) : unit = {
      sk <- sk_init;
      qs <- [];
    }

    (* 
      Sign given message m using the considered signature scheme with the
      secret/signing key sk and append m to the list of oracle queries qs
    *)
    proc sign(m : msg_t) : sig_t = {
      var sig : sig_t;
      
      sig <@ S.sign(sk, m);

      qs <- rcons qs m;
            
      return sig;
    }

    (* 
      Check whether given message m is fresh, i.e., whether m is not contained in
      the list of oracle queries qs 
    *)
    proc fresh(m : msg_t) : bool = {
      return ! m \in qs;
    }
    
    (* Get the number of oracle queries, i.e., the size of the oracle query list qs *)
    proc nr_queries() : int = {
      return size qs;
    }
  }.
  *)
  
  (* 
    - 
    Total Break under (Adaptive) Chosen-Message Attack (TB-CMA). 
    Given the public/verification key and the signatures for a set of adaptively
    chosen messages, the adversary is tasked with computing the secret key 
    corresponding to the public/verification key
    -
  *)
  (* Class of adversaries against TB-CMA *)
  quantum module type Adv_TBCMA_RO(R : QRO, O : SOracle_CMA) = {
    (* FIXME: include Adv_TBCMA(O) *)
    proc break(pk : pk_t) : sk_t
  }.

  (* TB-CMA game *)
  module TB_CMA_RO(S : Scheme_RO, A : Adv_TBCMA_RO, R : QRO_i, O : Oracle_CMA) = {
    proc main() : bool = {
      var is_inrngbreak : bool;
      
      R.init();
      
      is_inrngbreak <@ TB_CMA(S(R), A(R), O).main();
      
      return is_inrngbreak;  
    }
  }.

  (* TB-CMA game with Unlimited oracle queries *)
  module TB_CMA_U_RO(S : Scheme_RO, A : Adv_TBCMA_RO, R : QRO_i, O : Oracle_CMA) = {
    proc main() : bool = {
      var is_break : bool;
      
      R.init();
      
      is_break <@ TB_CMA_U(S(R), A(R), O).main();
      
      return is_break;  
    }
  }.
  
  
  (*
    - 
    Universal Forgery under (Adaptive) Chosen-Message Attack (UF-CMA)
    Given the public/verification key, the signatures for a set of adaptively
    chosen messages, and an arbitrary message, the adversary is tasked with forging 
    a signature for the given (latter) message
    -
  *)
  (* Class of adversaries against UF-CMA *)
  quantum module type Adv_UFCMA_RO(R : QRO, O : SOracle_CMA) = {
    proc forge(pk : pk_t, m : msg_t) : sig_t
  }.

  (* UF-CMA game *)
  module UF_CMA_RO(S : Scheme_RO, A : Adv_UFCMA_RO, R : QRO_i, O : Oracle_CMA) = {
    proc main() : bool = {
      var is_inrngvalidfresh : bool;
      
      R.init();
      
      is_inrngvalidfresh <@ UF_CMA(S(R), A(R), O).main();
      
      return is_inrngvalidfresh;  
    }
  }.

  (* UF-CMA game with Unlimited oracle queries *)
  module UF_CMA_U_RO(S : Scheme_RO, A : Adv_UFCMA_RO, R : QRO_i, O : Oracle_CMA) = {
    proc main() : bool = {
      var is_validfresh : bool;
      
      R.init();
      
      is_validfresh <@ UF_CMA_U(S(R), A(R), O).main();
      
      return is_validfresh;  
    }
  }.
  
  
  (*
    -
    Selective Forgery under Chosen-Message Attack (SF-CMA).
    After picking a message, the adversary is given the public/verification key 
    and the signatures for a set of adaptively chosen messages, and is tasked with 
    forging a signature for the picked message
    -
  *)
  (* Class of adversaries against SF-CMA *)
  quantum module type Adv_SFCMA_RO(R : QRO, O : SOracle_CMA) = {
    proc pick() : msg_t
    proc forge(pk : pk_t) : sig_t
  }.

  (* SF-CMA game *)
  module SF_CMA_RO(S : Scheme_RO, A : Adv_SFCMA_RO, R : QRO_i, O : Oracle_CMA) = {
    proc main() : bool = {
      var is_inrngvalidfresh : bool;
      
      R.init();
      
      is_inrngvalidfresh <@ SF_CMA(S(R), A(R), O).main();
      
      return is_inrngvalidfresh;  
    }
  }.

  (* SF-CMA game with Unlimited oracle queries *)
  module SF_CMA_U_RO(S : Scheme_RO, A : Adv_SFCMA_RO, R : QRO_i, O : Oracle_CMA) = {
    proc main() : bool = {
      var is_validfresh : bool;
      
      R.init();
      
      is_validfresh <@ SF_CMA_U(S(R), A(R), O).main();
      
      return is_validfresh;  
    }
  }.
  

  (*
    -
    Existential Forgery under Chosen-Message Attack (EF-CMA)
    Given the public/verification key and the signatures for a set of adaptively 
    chosen messages, the adversary is tasked with forging a signature for any fresh message
    -
  *)
  (* Class of adversaries against EF-CMA *)
  quantum module type Adv_EFCMA_RO(R : QRO, O : SOracle_CMA) = {
    proc forge(pk : pk_t) : msg_t * sig_t
  }.

  (* EF-CMA game *)
  module EF_CMA_RO(S : Scheme_RO, A : Adv_EFCMA_RO, R : QRO_i, O : Oracle_CMA) = {
    proc main() : bool = {
      var is_inrngvalidfresh : bool;
      
      R.init();
      
      is_inrngvalidfresh <@ EF_CMA(S(R), A(R), O).main();
      
      return is_inrngvalidfresh;  
    }
  }.

  (* EF-CMA game with Unlimited oracle queries *)
  module EF_CMA_U_RO(S : Scheme_RO, A : Adv_EFCMA_RO, R : QRO_i, O : Oracle_CMA) = {
    proc main() : bool = {
      var is_validfresh : bool;
      
      R.init();
      
      is_validfresh <@ EF_CMA_U(S(R), A(R), O).main();
      
      return is_validfresh;  
    }
  }.

  
  (*
    - 
    Strong Existential Forgery under Chosen-Message Attack (SEF-CMA).
    Given the public/verification key and the signatures for a set of adaptively 
    chosen messages, the adversary is tasked with forging a fresh signature for any message
    -
  *)
  (*
  (* 
    Type for signing oracles used in the SEF-CMA game, including procedures 
    for initialization and auxiliary tasks 
  *)
  module type Oracle_SEFCMA(S : Scheme) = {
    proc* init(sk_init : sk_t) : unit {}
    proc sign(m : msg_t) : sig_t {S.sign}
    proc fresh(msig : msg_t * sig_t) : bool {}
    proc nr_queries() : int {}
  }.

  (* 
    Type for signing oracles used in the SEF-CMA game, only exposing the 
    procedure for signing 
  *)
  module type SOracle_SEFCMA = {
    proc sign(m : msg_t) : sig_t
  }.
  
  (* 
    Default implementation of a signing oracle including procedures for 
    initialization and auxiliary tasks 
  *)
  module (O_SEFCMA_Default : Oracle_SEFCMA) (S : Scheme) = {
    var sk : sk_t
    var qs : (msg_t * sig_t) list
    
    (* Initialize secret/signing key and oracle query list qs *)
    proc init(sk_init : sk_t) : unit = {
      sk <- sk_init;
      qs <- [];
    }

    (* 
      Sign given message m using the considered signature scheme with the
      secret/signing key sk and append m to the list of oracle queries qs
    *)
    proc sign(m : msg_t) : sig_t = {
      var sig : sig_t;
      var msig : msg_t * sig_t;
      
      sig <@ S.sign(sk, m);

      msig <- (m, sig);
      qs <- rcons qs msig;
            
      return sig;
    }

    (* 
      Check whether given (message, signature) pair msig is fresh, i.e., whether this pair
      is not contained in the list of oracle queries qs 
    *)
    proc fresh(msig : msg_t * sig_t) : bool = {
      return ! msig \in qs;
    }
    
    (* Get the number of oracle queries, i.e., the size of the oracle query list qs *)
    proc nr_queries() : int = {
      return size qs;
    }
  }.
  *)
  
  (* Class of adversaries against SEF-CMA *)
  quantum module type Adv_SEFCMA_RO(R : QRO, O : SOracle_SEFCMA) = {
    proc forge(pk : pk_t) : msg_t * sig_t
  }.

  (* SEF-CMA game *)
  module SEF_CMA_RO(S : Scheme_RO, A : Adv_SEFCMA_RO, R : QRO_i, O : Oracle_SEFCMA) = {
    proc main() : bool = {
      var is_inrngvalidfresh : bool;
      
      R.init();
      
      is_inrngvalidfresh <@ SEF_CMA(S(R), A(R), O).main();
      
      return is_inrngvalidfresh;  
    }
  }.

  (* SEF-CMA game with Unlimited oracle queries *)
  module SEF_CMA_U_RO(S : Scheme_RO, A : Adv_SEFCMA_RO, R : QRO_i, O : Oracle_SEFCMA) = {
    proc main() : bool = {
      var is_validfresh : bool;
      
      R.init();
      
      is_validfresh <@ SEF_CMA_U(S(R), A(R), O).main();
      
      return is_validfresh;  
    }
  }.
end Stateless_RO.



(* --- Key-Updating (Stateful) Signature Schemes With Access to Random Oracles --- *)
theory KeyUpdating_RO.
  (* -- General -- *)
  (* Import theory for key-updating signature schemes (from QDigitalSignatures) *)
  import KeyUpdating.
  
  (* Module type for key-updating signature schemes with access to a random oracle *)
  module type Scheme_RO(O : QRO) = {
    include Scheme
  }.
  
  
  (* -- Correctness -- *)

  
  (*
    -- 
    Key-Only Attack (KOA).
    Attacks in which the adversary is only given the public/verification key
    -- 
  *)
  (*
    - 
    Total Break under Key-Only Attack (TB-KOA). 
    Given the public/verification key, the adversary is tasked with computing the
    corresponding secret key
    -
  *)
  (* Class of adversaries against TB-KOA *)
  quantum module type Adv_TBKOA_RO(O : QRO) = {
    include Adv_TBKOA
  }.
  
  (* TB-KOA game *)
  module TB_KOA_RO(S : Scheme_RO, A : Adv_TBKOA_RO, O : QRO_i) = {
    proc main() : bool = {
      var is_break : bool;
      
      O.init();
      
      is_break <@ TB_KOA(S(O), A(O)).main();
      
      return is_break;
    }
  }.
  
  
  (* 
    - 
    Universal Forgery under Key-Only Attack (UF-KOA).
    Given the public/verification key and an arbitrary message, the adversary is tasked 
    with forging a signature for the given message
    - 
  *)
  (* Class of adversaries against UF-KOA *)
  quantum module type Adv_UFKOA_RO(O : QRO) = {
    include Adv_UFKOA
  }.
  
  (* UF-KOA game *)
  module UF_KOA_RO(S : Scheme_RO, A : Adv_UFKOA_RO, O : QRO_i) = {
    proc main() : bool = {
      var is_valid : bool;
      
      O.init();
      
      is_valid <@ UF_KOA(S(O), A(O)).main();
      
      return is_valid;
    }
  }.

  
  (*
    - 
    Selective Forgery under Key-Only Attack (SF-KOA).
    After picking a message, the adversary is given the public/verification key and tasked
    with forging a signature for the picked message
    -
  *)
  (* Class of adversaries against SF-KOA *)
  quantum module type Adv_SFKOA_RO(O : QRO) = {
    include Adv_SFKOA
  }.

  (* SF-KOA game *)
  module SF_KOA_RO(S : Scheme_RO, A : Adv_SFKOA_RO, O : QRO_i) = {
    proc main() : bool = {
      var is_valid : bool;

      O.init();
      
      is_valid <@ SF_KOA(S(O), A(O)).main();

      return is_valid;
    }
  }.

  
  (*
    -
    Existential Forgery under Key-Only Attack (EF-KOA).
    Given the public/verification key, the adversary is tasked with forging a signature
    for any fresh message
    -
  *)
  (* Class of adversaries against EF-KOA *)
  quantum module type Adv_EFKOA_RO(O : QRO) = {
    proc forge(pk : pk_t) : msg_t * sig_t 
  }.

  (* EF-KOA game *)
  module EF_KOA_RO(S : Scheme_RO, A : Adv_EFKOA_RO, O : QRO_i) = {
    proc main() : bool = {
      var is_valid: bool;

      O.init();
      
      is_valid <@ EF_KOA(S(O), A(O)).main();

      return is_valid;
    }
  }.


  (* 
    -- 
    Random-Message Attack (RMA).
    Attacks in which the adversary is given the public/verification key as well as 
    the signatures for a set of random messages *known* to it, but not *chosen* by it
    -- 
  *)
  (* 
    - 
    Total Break under Random-Message Attack (TB-RMA). 
    Given the public/verification key and the signatures for a set of known random messages, 
    the adversary is tasked with computing the secret key corresponding to the 
    public/verification key
    -
  *)
  (* Class of adversaries against TB-RMA *)
  quantum module type Adv_TBRMA_RO(O : QRO) = {
    include Adv_TBRMA 
  }.
  
  (* TB-RMA game *)
  module TB_RMA_RO(S : Scheme_RO, A : Adv_TBRMA_RO, O : QRO_i) = {
    proc main() : bool = {
      var is_break : bool;
      
      O.init();
      
      is_break <@ TB_RMA(S(O), A(O)).main(); 
      
      return is_break;
    }
  }.
  
  
  (* 
    - 
    Universal Forgery under Random-Message Attack (UF-RMA).
    Given the public/verification key, the signatures for a set of known random messages, 
    and an arbitrary message, the adversary is tasked with forging a signature for 
    the given (latter) message
    -
  *)
  (* Class of adversaries against UF-RMA *)
  quantum module type Adv_UFRMA_RO(O : QRO) = {
    include Adv_UFRMA
  }.
  
  (* UF-RMA game *)
  module UF_RMA_RO(S : Scheme_RO, A : Adv_UFRMA_RO, O : QRO_i) = {
    proc main() : bool = {
      var is_validfresh : bool;
      
      O.init();
      
      is_validfresh <@ UF_RMA(S(O), A(O)).main();
      
      return is_validfresh;
    }
  }.
  

  (*
    -
    Selective Forgery under Random-Message Attack (SF-RMA).
    After picking a message, the adversary is given the public/verification key, 
    the signatures for a set of known random messages, and an arbitrary message, and is tasked
    with forging a signature for the picked message
    -
  *)
  (* Class of adversaries against SF-RMA *)
  quantum module type Adv_SFRMA_RO(O : QRO) = {
    include Adv_SFRMA
  }.

  (* SF-RMA game *)
  module SF_RMA_RO(S : Scheme_RO, A : Adv_SFRMA_RO, O : QRO_i) = {
    proc main() : bool = {
      var is_validfresh : bool;

      O.init();
      
      is_validfresh <@ SF_RMA(S(O), A(O)).main();
      
      return is_validfresh;
    }
  }.

  
  (*
    -
    Existential Forgery under Random-Message Attack (EF-RMA)
    Given the public/verification key and the signatures for a set of known random messages,
    the adversary is tasked with forging a signature for any fresh message
    -
  *)
  (* Class of adversaries against EF-RMA *)
  quantum module type Adv_EFRMA_RO(O : QRO) = {
    include Adv_EFRMA
  }.

  module EF_RMA_RO(S : Scheme_RO, A : Adv_EFRMA_RO, O : QRO_i) = {   
    proc main() : bool = {
      var is_validfresh : bool;
      
      O.init();
      
      is_validfresh <@ EF_RMA(S(O), A(O)).main();
      
      return is_validfresh;
    }
  }.
  
  
  (* Class of adversaries against EF-RMA *)
  quantum module type Adv_I_EFRMA_RO (O : QRO, SO : SOracle_RMA) = {
      proc forge(pk : pk_t) : msg_t * sig_t
  }.
  
  (* I_EF-RMA game *)
  module I_EF_RMA_RO(S : Scheme_RO, A : Adv_I_EFRMA_RO, SO: Oracle_RMA, O : QRO_i) = { 
    proc main() : bool = {
    var is_validfresh : bool;
    
    O.init();
    
    is_validfresh <@ I_EF_RMA(S(O), A(O), SO).main();
    
    return is_validfresh;
    }
  }.  

  (*
    -- 
    Generic Chosen-Message Attack (GCMA).
    Attacks in which the adversary is given the public/verification key as well as
    the signatures for a set of *chosen* messages. Here, all messages are chosen
    (1) non-adaptively; that is, before obtaining any of the signatures, and
    (2) independently of the public key; that is, without knowing the public key
        at the time of choosing the messages
    --
  *)
  (* 
    - 
    Total Break under Generic Chosen-Message Attack (TB-GCMA). 
    Given the public/verification key and the signatures for a set of messages chosen
    non-adaptively and indepedently of the public key, the adversary is tasked with 
    computing the secret key corresponding to the public/verification key
    -
  *)
  (* Class of adversaries against TB-GCMA *)
  quantum module type Adv_TBGCMA_RO(O : QRO) = {
    include Adv_TBGCMA
  }.
  
  (* TB-GCMA game *)
  module TB_GCMA_RO(S : Scheme_RO, A : Adv_TBGCMA_RO, O : QRO_i) = {
    proc main() : bool = {
      var is_break : bool;
      
      O.init();
      
      is_break <@ TB_GCMA(S(O), A(O)).main(); 
      
      return is_break; 
    }
  }.
  
  
  (*
    - 
    Universal Forgery under Generic Chosen-Message Attack (UF-GCMA).
    Given the public/verification key, the signatures for a set of messages chosen
    non-adaptively and indepedently of the public key, and an arbitrary message, 
    the adversary is tasked with forging a signature for the given (latter) message
    -
  *)
  (* Class of adversaries against UF-GCMA *)
  quantum module type Adv_UFGCMA_RO(O : QRO) = {
    include Adv_UFGCMA
  }.

  (* UF-GCMA game *)
  module UF_GCMA_RO(S : Scheme_RO, A : Adv_UFGCMA_RO, O : QRO_i) = {
    proc main() : bool = {
      var is_validfresh : bool;
      
      O.init();
      
      is_validfresh <@ UF_GCMA(S(O), A(O)).main();
      
      return is_validfresh;
    }
  }.

  
  (* 
    - 
    Selective Forgery under Generic Chosen-Message Attack (SF-GCMA).
    After picking a message, the adversary is given the public/verification key and
    the signatures for a set of messages chosen non-adaptively and indepedently 
    of the public key, and is tasked with forging a signature for the picked message
    -
  *)
  (* Class of adversaries against SF-GCMA *)
  quantum module type Adv_SFGCMA_RO(O : QRO) = {
    proc pick() : msg_t
    proc choose() : msg_t list
    proc forge(pk : pk_t, sigl : sig_t list) : sig_t
  }.

  (* SF-GCMA game *)
  module SF_GCMA_RO(S : Scheme_RO, A : Adv_SFGCMA_RO, O : QRO_i) = {
    proc main() : bool = {
      var is_validfresh : bool;
      
      O.init();
      
      is_validfresh <@ SF_GCMA(S(O), A(O)).main();
      
      return is_validfresh; 
    }
  }.

  
  (*
    -
    Existential Forgery under Generic Chosen-Message Attack (EF-GCMA)
    Given the public/verification key and the signatures for a set of messages 
    chosen non-adaptively and indepedently of the public key, the adversary is tasked 
    with forging a signature for any fresh message
    -
  *)
  (* Class of adversaries against EF-GCMA *)
  quantum module type Adv_EFGCMA_RO(O : QRO) = {
    include Adv_EFGCMA
  }.
  
  (* EF-GCMA game *)
  module EF_GCMA_RO(S : Scheme_RO, A : Adv_EFGCMA_RO, O : QRO_i) = {   
    proc main() : bool = {
      var is_validfresh : bool;
      
      O.init();
      
      is_validfresh <@ EF_GCMA(S(O), A(O)).main();
      
      return is_validfresh;  
    }  
  }.  

  
  (*
    -- 
    Non-Adaptive Chosen-Message Attack (NACMA)/Directed Chosen-Message Attack (DCMA).
    Attacks in which the adversary is given the public/verification key as well as
    the signatures for a set of *chosen* messages. Here, all messages are chosen
    non-adaptively; that is, before obtaining any of the signatures. However, the chosen
    messages may depend on the public key; i.e., the adversary is given the public key
    when asked to provide the messages
    --
  *)
  (* 
    - 
    Total Break under Non-Adaptive Chosen-Message Attack (TB-NACMA). 
    Given the public/verification key and the signatures for a set of non-adaptively
    chosen messages, the adversary is tasked with computing the secret key 
    corresponding to the public/verification key
    -
  *)
  (* Class of adversaries against TB-NACMA *)
  quantum module type Adv_TBNACMA_RO(O : QRO) = {
    include Adv_TBNACMA
  }.
  
  (* TB-NACMA game *)
  module TB_NACMA_RO(S : Scheme_RO, A : Adv_TBNACMA_RO, O : QRO_i) = {
    proc main() : bool = {
      var is_break : bool;
      
      O.init();
      
      is_break <@ TB_NACMA(S(O), A(O)).main();
      
      return is_break; 
    }
  }.
  
  
  (*
    - 
    Universal Forgery under Non-Adaptive Chosen-Message Attack (UF-NACMA).
    Given the public/verification key, the signatures for a set of non-adaptively
    chosen messages, and an arbitrary message, the adversary is tasked with forging 
    a signature for the given (latter) message
    -
  *)
  (* Class of adversaries against UF-NACMA *)
  quantum module type Adv_UFNACMA_RO(O : QRO) = {
    include Adv_UFNACMA
  }.

  (* UF-NACMA game *)
  module UF_NACMA_RO(S : Scheme_RO, A : Adv_UFNACMA_RO, O : QRO_i) = {
    proc main() : bool = {
      var is_validfresh : bool;
      
      O.init();
      
      is_validfresh <@ UF_NACMA(S(O), A(O)).main();
      
      return is_validfresh; 
    }
  }.

  
  (* 
    - 
    Selective Forgery under Non-Adaptive Chosen-Message Attack (SF-NACMA).
    After picking a message, the adversary is given the public/verification key and
    the signatures for a set of non-adaptively chosen messages, and is tasked with 
    forging a signature for the picked message
    -
  *)
  (* Class of adversaries against SF-NACMA *)
  quantum module type Adv_SFNACMA_RO(O : QRO) = {
    include Adv_SFNACMA
  }.

  (* SF-NACMA game *)
  module SF_NACMA_RO(S : Scheme_RO, A : Adv_SFNACMA_RO, O : QRO_i) = {
    proc main() : bool = {
      var is_validfresh : bool;
      
      O.init();
      
      is_validfresh <@ SF_NACMA(S(O), A(O)).main();
      
      return is_validfresh; 
    }
  }.

  
  (*
    -
    Existential Forgery under Non-Adaptive Chosen-Message Attack (EF-NACMA).
    Given the public/verification key and the signatures for a set of non-adaptively
    chosen messages the adversary is tasked with forging a signature for any fresh message
    -
  *)
  (* Class of adversaries against EF-NACMA *)
  quantum module type Adv_EFNACMA_RO(O : QRO) = {
    include Adv_EFNACMA
  }.
  
  (* EF-NACMA game *)
  module EF_NACMA_RO(S : Scheme_RO, A : Adv_EFNACMA_RO, O : QRO_i) = {   
    proc main() : bool = {
      var is_validfresh : bool;
      
      O.init();
      
      is_validfresh <@ EF_NACMA(S(O), A(O)).main();
      
      return is_validfresh; 
    }  
  }.  

  
  (*
    --
    (Adaptive) Chosen-Message Attack (CMA).
    Attacks in which the adversary is given the public/verification key as well as
    the signatures for a set of *chosen* messages. Here, all messages are chosen
    adaptively and may depend on the public key; that is, the adversary 
    (1) immediately receives a signature for a chosen message before choosing the 
        subsequent message, and
    (2) is given the public key when asked to provide the messages.
    --
  *)
  (*
  (* - General - *)
  (* Maximum number of oracle queries the adversary is allowed to make in TB-CMA game *)
  const q_tbcma : { int | 0 <= q_tbcma } as ge0_qtbcma.
  
  (* Maximum number of oracle queries the adversary is allowed to make in UF-CMA game *)
  const q_ufcma : { int | 0 <= q_ufcma } as ge0_qufcma.
  
  (* Maximum number of oracle queries the adversary is allowed to make in SF-CMA game *)
  const q_sfcma : { int | 0 <= q_sfcma } as ge0_qsfcma.
  
  (* Maximum number of oracle queries the adversary is allowed to make in EF-CMA game *)
  const q_efcma : { int | 0 <= q_efcma } as ge0_qefcma.
  
  (* Maximum number of oracle queries the adversary is allowed to make in SEF-CMA game *)
  const q_sefcma : { int | 0 <= q_sefcma } as ge0_qsefcma.
 
  (* 
    Type for signing oracles used in (adaptive) CMA game, including procedures 
    for initialization and auxiliary tasks 
  *)
  module type Oracle_CMA(S : Scheme) = {
    proc* init(sk_init : sk_t) : unit {}
    proc sign(m : msg_t) : sig_t { S.sign }
    proc fresh(m : msg_t) : bool {}
    proc nr_queries() : int {}
  }.

  (* 
    Type for signing oracles used in (adaptive) CMA games, only exposing the 
    procedure for signing 
  *)
  module type SOracle_CMA = {
    proc sign(m : msg_t) : sig_t
  }.
  
  (* 
    Default implementation of a signing oracle including procedures for 
    initialization and auxiliary tasks 
  *)
  module (O_CMA_Default : Oracle_CMA) (S : Scheme) = {
    var sk : sk_t
    var qs : msg_t list
    
    (* Initialize secret/signing key and oracle query list qs *)
    proc init(sk_init : sk_t) : unit = {
      sk <- sk_init;
      qs <- [];
    }

    (* 
      Sign given message m using the considered signature scheme with the
      secret/signing key sk and append m to the list of oracle queries qs
    *)
    proc sign(m : msg_t) : sig_t = {
      var sig : sig_t;
      
      sig <@ S.sign(sk, m);

      qs <- rcons qs m;
            
      return sig;
    }

    (* 
      Check whether given message m is fresh, i.e., whether m is not contained in
      the list of oracle queries qs 
    *)
    proc fresh(m : msg_t) : bool = {
      return ! m \in qs;
    }
    
    (* Get the number of oracle queries, i.e., the size of the oracle query list qs *)
    proc nr_queries() : int = {
      return size qs;
    }
  }.
  *)
  
  (* 
    - 
    Total Break under (Adaptive) Chosen-Message Attack (TB-CMA). 
    Given the public/verification key and the signatures for a set of adaptively
    chosen messages, the adversary is tasked with computing the secret key 
    corresponding to the public/verification key
    -
  *)
  (* Class of adversaries against TB-CMA *)
  quantum module type Adv_TBCMA_RO(R : QRO, O : SOracle_CMA) = {
    (* FIXME: include Adv_TBCMA(O) *)
    proc break(pk : pk_t) : sk_t
  }.

  (* TB-CMA game *)
  module TB_CMA_RO(S : Scheme_RO, A : Adv_TBCMA_RO, R : QRO_i, O : Oracle_CMA) = {
    proc main() : bool = {
      var is_inrngbreak : bool;
      
      R.init();
      
      is_inrngbreak <@ TB_CMA(S(R), A(R), O).main();
      
      return is_inrngbreak;  
    }
  }.

  (* TB-CMA game with Unlimited oracle queries *)
  module TB_CMA_U_RO(S : Scheme_RO, A : Adv_TBCMA_RO, R : QRO_i, O : Oracle_CMA) = {
    proc main() : bool = {
      var is_break : bool;
      
      R.init();
      
      is_break <@ TB_CMA_U(S(R), A(R), O).main();
      
      return is_break;  
    }
  }.
  
  
  (*
    - 
    Universal Forgery under (Adaptive) Chosen-Message Attack (UF-CMA)
    Given the public/verification key, the signatures for a set of adaptively
    chosen messages, and an arbitrary message, the adversary is tasked with forging 
    a signature for the given (latter) message
    -
  *)
  (* Class of adversaries against UF-CMA *)
  quantum module type Adv_UFCMA_RO(R : QRO, O : SOracle_CMA) = {
    proc forge(pk : pk_t, m : msg_t) : sig_t
  }.

  (* UF-CMA game *)
  module UF_CMA_RO(S : Scheme_RO, A : Adv_UFCMA_RO, R : QRO_i, O : Oracle_CMA) = {
    proc main() : bool = {
      var is_inrngvalidfresh : bool;
      
      R.init();
      
      is_inrngvalidfresh <@ UF_CMA(S(R), A(R), O).main();
      
      return is_inrngvalidfresh;  
    }
  }.

  (* UF-CMA game with Unlimited oracle queries *)
  module UF_CMA_U_RO(S : Scheme_RO, A : Adv_UFCMA_RO, R : QRO_i, O : Oracle_CMA) = {
    proc main() : bool = {
      var is_validfresh : bool;
      
      R.init();
      
      is_validfresh <@ UF_CMA_U(S(R), A(R), O).main();
      
      return is_validfresh;  
    }
  }.
  
  
  (*
    -
    Selective Forgery under Chosen-Message Attack (SF-CMA).
    After picking a message, the adversary is given the public/verification key 
    and the signatures for a set of adaptively chosen messages, and is tasked with 
    forging a signature for the picked message
    -
  *)
  (* Class of adversaries against SF-CMA *)
  quantum module type Adv_SFCMA_RO(R : QRO, O : SOracle_CMA) = {
    proc pick() : msg_t
    proc forge(pk : pk_t) : sig_t
  }.

  (* SF-CMA game *)
  module SF_CMA_RO(S : Scheme_RO, A : Adv_SFCMA_RO, R : QRO_i, O : Oracle_CMA) = {
    proc main() : bool = {
      var is_inrngvalidfresh : bool;
      
      R.init();
      
      is_inrngvalidfresh <@ SF_CMA(S(R), A(R), O).main();
      
      return is_inrngvalidfresh;  
    }
  }.

  (* SF-CMA game with Unlimited oracle queries *)
  module SF_CMA_U_RO(S : Scheme_RO, A : Adv_SFCMA_RO, R : QRO_i, O : Oracle_CMA) = {
    proc main() : bool = {
      var is_validfresh : bool;
      
      R.init();
      
      is_validfresh <@ SF_CMA_U(S(R), A(R), O).main();
      
      return is_validfresh;  
    }
  }.
  

  (*
    -
    Existential Forgery under Chosen-Message Attack (EF-CMA)
    Given the public/verification key and the signatures for a set of adaptively 
    chosen messages, the adversary is tasked with forging a signature for any fresh message
    -
  *)
  (* Class of adversaries against EF-CMA *)
  quantum module type Adv_EFCMA_RO(R : QRO, O : SOracle_CMA) = {
    proc forge(pk : pk_t) : msg_t * sig_t
  }.

  (* EF-CMA game *)
  module EF_CMA_RO(S : Scheme_RO, A : Adv_EFCMA_RO, R : QRO_i, O : Oracle_CMA) = {
    proc main() : bool = {
      var is_inrngvalidfresh : bool;
      
      R.init();
      
      is_inrngvalidfresh <@ EF_CMA(S(R), A(R), O).main();
      
      return is_inrngvalidfresh;  
    }
  }.

  (* EF-CMA game with Unlimited oracle queries *)
  module EF_CMA_U_RO(S : Scheme_RO, A : Adv_EFCMA_RO, R : QRO_i, O : Oracle_CMA) = {
    proc main() : bool = {
      var is_validfresh : bool;
      
      R.init();
      
      is_validfresh <@ EF_CMA_U(S(R), A(R), O).main();
      
      return is_validfresh;  
    }
  }.

  
  (*
    - 
    Strong Existential Forgery under Chosen-Message Attack (SEF-CMA).
    Given the public/verification key and the signatures for a set of adaptively 
    chosen messages, the adversary is tasked with forging a fresh signature for any message
    -
  *)
  (*
  (* 
    Type for signing oracles used in the SEF-CMA game, including procedures 
    for initialization and auxiliary tasks 
  *)
  module type Oracle_SEFCMA(S : Scheme) = {
    proc* init(sk_init : sk_t) : unit {}
    proc sign(m : msg_t) : sig_t {S.sign}
    proc fresh(msig : msg_t * sig_t) : bool {}
    proc nr_queries() : int {}
  }.

  (* 
    Type for signing oracles used in the SEF-CMA game, only exposing the 
    procedure for signing 
  *)
  module type SOracle_SEFCMA = {
    proc sign(m : msg_t) : sig_t
  }.
  
  (* 
    Default implementation of a signing oracle including procedures for 
    initialization and auxiliary tasks 
  *)
  module (O_SEFCMA_Default : Oracle_SEFCMA) (S : Scheme) = {
    var sk : sk_t
    var qs : (msg_t * sig_t) list
    
    (* Initialize secret/signing key and oracle query list qs *)
    proc init(sk_init : sk_t) : unit = {
      sk <- sk_init;
      qs <- [];
    }

    (* 
      Sign given message m using the considered signature scheme with the
      secret/signing key sk and append m to the list of oracle queries qs
    *)
    proc sign(m : msg_t) : sig_t = {
      var sig : sig_t;
      var msig : msg_t * sig_t;
      
      sig <@ S.sign(sk, m);

      msig <- (m, sig);
      qs <- rcons qs msig;
            
      return sig;
    }

    (* 
      Check whether given (message, signature) pair msig is fresh, i.e., whether this pair
      is not contained in the list of oracle queries qs 
    *)
    proc fresh(msig : msg_t * sig_t) : bool = {
      return ! msig \in qs;
    }
    
    (* Get the number of oracle queries, i.e., the size of the oracle query list qs *)
    proc nr_queries() : int = {
      return size qs;
    }
  }.
  *)
  
  (* Class of adversaries against SEF-CMA *)
  quantum module type Adv_SEFCMA_RO(R : QRO, O : SOracle_SEFCMA) = {
    proc forge(pk : pk_t) : msg_t * sig_t
  }.

  (* SEF-CMA game *)
  module SEF_CMA_RO(S : Scheme_RO, A : Adv_SEFCMA_RO, R : QRO_i, O : Oracle_SEFCMA) = {
    proc main() : bool = {
      var is_inrngvalidfresh : bool;
      
      R.init();
      
      is_inrngvalidfresh <@ SEF_CMA(S(R), A(R), O).main();
      
      return is_inrngvalidfresh;  
    }
  }.

  (* SEF-CMA game with Unlimited oracle queries *)
  module SEF_CMA_U_RO(S : Scheme_RO, A : Adv_SEFCMA_RO, R : QRO_i, O : Oracle_SEFCMA) = {
    proc main() : bool = {
      var is_validfresh : bool;
      
      R.init();
      
      is_validfresh <@ SEF_CMA_U(S(R), A(R), O).main();
      
      return is_validfresh;  
    }
  }.
end KeyUpdating_RO.
