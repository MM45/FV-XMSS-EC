(**************************************************************************)
(* File containing everything related to keyed hash functions.            *)
(* This file is based on the material from several papers.                *) 
(* More precisely, this concerns the following references:                *)
(* - "Cryptographic Hash-Function Basics: Definitions, Implications, and  *)
(*    Separations for Preimage Resistance, Second-Preimage Resistance,    *)
(*    and Collision Resistance"                                           *)
(*   DOI: 10.1007/978-3-540-25937-4_24                                    *) 
(* - "Mitigating Multi-Target Attacks in Hash-based Signatures"           *)
(*   DOI: 10.1007/978-3-662-49384-7_15                                    *)
(* - "Decisional second-preimage resistance: When does SPR imply PRE?"    *)
(*   DOI: 10.1007/978-3-030-34618-8_2                                     *)
(* - "The SPHINCS+ Signature Framework."                                  *)
(*   DOI: 10.1145/3319535.3363229                                         *)
(* - "Recovering the Tight Security Proof of SPHINCS+"                    *)
(*   DOI: 10.1007/978-3-031-22972-5_1                                     *)
(**************************************************************************)

(* --- Require/Import --- *)
(* -- Built-in (i.e, standard library) -- *)
require import AllCore StdOrder List Distr DInterval Finite SmtMap.
require (*--*) PlugAndPray.
(*---*) import RField RealOrder.



(*
---
  Preliminary Note:
  The ensuing formalizes the concept of keyed hash functions and several
  properties of such functions. For most of these properties, there are 
  several variants based on the number of considered functions and/or the number of
  considered targets. Independent of the property, these variants always deviate from the
  basic property in the same manner. Below, we describe how each of these variants differs
  from the basic property. 
  
  - single-function, single-target:
    In most cases, this is the default 'variant' of the property (i.e., the standard/basic property). 
    This considers only a single function (or, equivalently, single index key) and a single target 
    (e.g., a single input or single output) with/for which the adversary can try to break the 
    considered property.
    
  - Single-function, Multi-target (SM):
    This variant considers a single function (or, equivalently, single index key) and multiple
    targets with/for which the adversary can try to break the considered property.
  
  - Multi-function, Multi-target (MM):
    This variant considers multiple functions (or, equivalently, multiple index keys) and multiple
    targets with/for which the adversary can try to break the considered property.
    
  - Distinct-function, Multi-target (DM):
    This variant considers multiple functions (or, equivalently, multiple index keys) and multiple
    targets with/for which the adversary can try to break the considered property. Here, in contrast
    to the MM variant, the functions are required to be distinct from each other.
---
*)



(* --- General --- *)
(* -- Types -- *)
(* Types for inputs ('messages') and, respectively, outputs ('message digests') of hash function *)
type in_t.
type out_t.

(* Type for (indexing) keys *)
type key_t. 


(* -- Operators -- *)
(* Keyed hash function *)
op f : key_t -> in_t -> out_t.


(* -- Distributions -- *)
(* (Proper) Distributions over input type, output type, and (indexing) key type, respectively *)
op [lossless] din : in_t distr.
op [lossless] dout : out_t distr.
op [lossless] dkey : key_t distr.



(* --- Properties --- *)
(* 
-- 
  PREimage resistance (PRE) / One-Wayness (OW).
  Given a key k and an output y, it is hard to find an input x such that f k x = y
-- 
*)
(* - single-function, single-target PREimage resistance (PRE) - *)
(* Class of adversaries against PRE *) 
module type Adv_PRE = {
  proc find(k : key_t, y : out_t) : in_t
}.

(* PRE game *)
module PRE(A : Adv_PRE) = {
  proc main() : bool = {
    var k : key_t;
    var x, x' : in_t;
    var y : out_t;
    
    (* Sample key k and input x *)
    k <$ dkey;
    x <$ din;
    
    (* Compute output y of hash function when given key k and input x *)
    y <- f k x;
    
    (* Ask adversary to find a preimage x' of y *)
    x' <@ A.find(k, y);

    (* Success iff x' is a preimage of y, i.e., if f k maps x' to y *)
    return f k x' = y;
  }
}.


(* - Single-function, Multi-target PREimage resistance (SM_PRE) - *)
(* Number of targets in SM_PRE *)
const t_smpre : { int | 1 <= t_smpre } as ge1_tsmpre.

(* Class of adversaries against SM_PRE *) 
module type Adv_SMPRE = {
  proc find(k : key_t, yl : out_t list) : int * in_t
}.

(* SM_PRE game *)
module SM_PRE(A : Adv_SMPRE) = {
  proc main() : bool = {
    var k : key_t;
    var x, x' : in_t;
    var y : out_t;
    var yl : out_t list;
    var i : int;
    
    (* Sample key k *)
    k <$ dkey;
    
    (* 
      Construct list yl of size t_smpre containing outputs obtained
      by applying f k to randomly sampled inputs
    *)
    yl <- [];
    while (size yl < t_smpre) {
      x <$ din;
      y <- f k x;
      yl <- rcons yl y;  
    }
    
    (* Ask adversary to find a preimage x' of any output in yl *)
    (i, x') <@ A.find(k, yl);
    
    (* Get key k and output y from yl at index i, as specified by the adversary *)
    y <- nth witness yl i;
    
    (* 
      Success iff 
      (1) "0 <= i < size yl": index i provided by adversary is within the bounds of yl
          (i.e., between 0 (including) and the size yl = t_smpre (excluding)), and
      (2) "f k x' = y": x' is a preimage of y under f k
    *)
    return 0 <= i < size yl /\ f k x' = y;
  }
}.


(* - Multi-function, Multi-target PREimage resistance (MM_PRE) - *)
(* Number of functions/targets in MM_PRE *)
const t_mmpre : { int | 1 <= t_mmpre } as ge1_tmmpre.

(* Class of adversaries against MM_PRE *) 
module type Adv_MMPRE = {
  proc find(kyl : (key_t * out_t) list) : int * in_t
}.

(* MM_PRE game *)
module MM_PRE(A : Adv_MMPRE) = {
  proc main() : bool = {
    var k : key_t;
    var x, x' : in_t;
    var y : out_t;
    var ky : key_t * out_t;
    var kyl : (key_t * out_t) list;
    var i : int;
    
    (*
      Construct list kyl of t_mmpre (key, output) pairs (k, y).
      For each pair, key k is randomly sampled, 
      after which output y is obtained by applying f k
      to a randomly sampled input            
    *)
    kyl <- [];
    while (size kyl < t_mmpre) {
      k <$ dkey;
      x <$ din;
      y <- f k x;
      ky <- (k, y);
      kyl <- rcons kyl ky;
    }
    
    (* 
      Ask adversary to find a preimage of an output in any 
      (key, output) pair in kyl w.r.t. the key in the (same) pair 
    *)
    (i, x') <@ A.find(kyl);
    
    (* Get (key, output) pair ky from kyl at index i, as specified by adversary *)
    ky <- nth witness kyl i;
    
    (* Extract key k and, respecively, output y from ky *)
    k <- ky.`1;
    y <- ky.`2;
    
    (* 
      Success iff 
      (1) "0 <= i < size kyl": index provided by adversary is within the bounds of kyl 
          (i.e., between 0 (including) and size kyl = t_mmpre (excluding)), and
      (2) "f k x' = y": f k maps x' to y 
    *)
    return 0 <= i < size kyl /\ f k x' = y;
  }
}.


(* - Distinct-function, Multi-target PREimage resistance (DM_PRE) - *)
(* Number of functions/targets in DM_PRE *)
const t_dmpre : { int | 1 <= t_dmpre } as ge1_tdmpre.

(* Class of adversaries against DM_PRE *) 
module type Adv_DMPRE = {
  proc pick() : key_t list
  proc find(yl : out_t list) : int * in_t
}.

(* DM_PRE game *)
module DM_PRE(A : Adv_DMPRE) = {
  proc main() : bool = {
    var k : key_t;
    var x, x' : in_t;
    var y : out_t;
    var kl : key_t list;
    var yl : out_t list;
    var i : int;
  
    (* 
      Ask adversary to provide a list kl of keys that will be used to index f.
      As indicated in the return statement, this list must not contain duplicate 
      elements (so that indexing f with each element gives a distinct function)
    *) 
    kl <@ A.pick();
    
    (*
      Construct list yl of a size equal to the minimum of t_dmpre and the size of kl.
      In yl, the element at index i is the mapping of a randomly sampled input 
      under the function obtained fromindexing f with the element of kl at index i.
      That is, if the i-th element of kl is k, then the i-th element of 
      yl is obtained by applying f k to a randomly sampled input
    *)
    yl <- [];
    while (size yl < min t_dmpre (size kl)) {
      k <- nth witness kl (size yl);
      x <$ din;
      y <- f k x;
      yl <- rcons yl y;
    }
    
    (* 
      Ask adversary to find a preimage for any output
      in yl w.r.t. the corresponding  (i.e., at the same index) key in kl
    *)
    (i, x') <@ A.find(yl);
    
    (* 
      Get key k and output y from kl and, respectively, yl at index i, 
      as specified by the adversary 
    *)
    k <- nth witness kl i;
    y <- nth witness yl i; 
    
    (* 
      Success iff
      (1) "0 <= i < min t_dmpre (size kl)": index provided by adversary is within the allowed 
          bounds of kl (i.e., between 0 (including) and the minimum of t_dmpre and 
          size kl (excluding)), and
      (2) "uniq kl": kl contains no duplicate elements, and
      (3) "f k x' = y": f k maps x' to y
    *)
    return 0 <= i < min t_dmpre (size kl) /\ uniq kl /\ f k x' = y;
  }
}.


(* 
-- 
  Second Preimage Resistance (SPR).
  Given a key k and input x, it is hard to find an input x' that is different from x
  such that f k x = f k x'
-- 
*)
(* - single-function, single-target Second Preimage Resistance (SPR) - *)
(* Class of adversaries against SPR *) 
module type Adv_SPR = {
  proc find(k : key_t, x : in_t) : in_t
}.

(* SPR game *)
module SPR(A : Adv_SPR) = {
  proc main() : bool  = {
    var k : key_t;
    var x, x' : in_t;
    
    (* Sample key k and input x *)
    k <$ dkey;
    x <$ din;
    
    (* Ask adversary to find a second preimage x' of x w.r.t. k (i.e., under f k) *)
    x' <@ A.find(k, x);
    
    (* 
      Success iff
      (1) "x <> x'": x does not equal x', and
      (2) "f k x = f k x'": f k maps x to the same element as it maps x'
    *)
    return x <> x' /\ f k x = f k x';
  }
}.


(* - Single-function, Multi-target Second Preimage Resistance (SM_SPR) - *)
(* Number of targets in SM_SPR *)
const t_smspr : { int | 1 <= t_smspr } as ge1_tsmspr.

(* Class of adversaries against SM_SPR *)
module type Adv_SMSPR = {
  proc find(k : key_t, xl : in_t list) : int * in_t
}.

(* SM_SPR game *)
module SM_SPR(A : Adv_SMSPR) = {
  proc main() : bool  = {
    var k : key_t;
    var x, x' : in_t;
    var xl : in_t list;
    var i : int;
    
    (* Sample key k *)
    k <$ dkey;
    
    (* Construct list xl of t_smspr randomly sampled inputs *)
    xl <- [];
    while (size xl < t_smspr) {
      x <$ din;
      xl <- rcons xl x;
    }
    
    (* Ask adversary to find second preimage for any input in xl *)
    (i, x') <@ A.find(k, xl);
    
    (* Get input from xl at index i, as specified by the adversary *)
    x <- nth witness xl i;
     
    (* 
      Success iff
      (1) "0 <= i < size xl": index i provided by adversary is within the bounds of xl
          (i.e., between 0 (including) and the size xl = t_smspr (excluding)), and
      (2) "x <> x'": x does not equal x'
      (3) "f k x = f k x'": f k maps x to the same element as it maps x'  
    *)
    return 0 <= i < size xl /\ x <> x' /\ f k x = f k x';
  }
}.


(* - Multi-function, Multi-target Second Preimage Resistance (MM_SPR) - *)
(* Number of functions/targets in MM_SPR *)
const t_mmspr : { int | 1 <= t_mmspr } as ge1_tmmspr.

(* Class of adversaries against MM_SPR *)
module type Adv_MMSPR = {
  proc find(kxl : (key_t * in_t) list) : int * in_t
}.

(* MM_SPR game *)
module MM_SPR(A : Adv_MMSPR) = {
  proc main() : bool  = {
    var k : key_t;
    var x, x' : in_t;
    var kx : key_t * in_t;
    var kxl : (key_t * in_t) list;
    var i : int;
    
    (*
      Construct list kxl of size t_mmspr containing (key, input) pairs (k, x).
      For each pair, key k and input x are both randomly sampled from
      their respective distributions
    *)
    kxl <- [];
    while (size kxl < t_mmspr) {
      k <$ dkey;
      x <$ din;
      kx <- (k, x);
      kxl <- rcons kxl kx;
    }
    
    (* 
      Ask adversary to find a second preimage for an input in any
      (key, input) pair in kxl w.r.t. the key in the (same) pair   
    *)
    (i, x') <@ A.find(kxl);
    
    (* Get (key, input) pair kx from kxl at index i, as specified by the adversary *)
    kx <- nth witness kxl i;
    
    (* Extract key k and, respectively, input x from kx *)
    k <- kx.`1;
    x <- kx.`2;
    
    (*
      Success iff
      (1) "0 <= i < size kxl": index provided by adversary is within the bounds of kyl 
          (i.e., between 0 (including) and size kxl = t_mmspr (excluding)), and
      (2) "x <> x'": x does not equal x', and
      (3) "f k x = f k x'": f k maps x to the same element as it maps x'
    *)
    return 0 <= i < size kxl /\ x <> x' /\ f k x = f k x';
  }
}.


(* - Distinct-function, Multi-target Second Preimage Resistance (DM_SPR) - *)
(* Number of functions/targets in DM_SPR *)
const t_dmspr : { int | 1 <= t_dmspr } as ge1_tdmspr.

(* Class of adversaries against DM_SPR *)
module type Adv_DMSPR = {
  proc pick() : key_t list
  proc find(xl : in_t list) : int * in_t
}.

(* DM_SPR game *)
module DM_SPR(A : Adv_DMSPR) = {
  proc main() : bool = {
    var k : key_t;
    var x, x' : in_t;
    var kl : key_t list;
    var xl : in_t list;
    var i : int;
  
    (* 
      Ask adversary to provide a list kl of keys that will be used to index f.
      As indicated in the return statement, this list must not contain duplicate 
      elements (so that indexing f with each element gives a distinct function)
    *)
    kl <@ A.pick();
    
    (*
      Construct list xl of a size equal to the minimum of 
      t_dmspr and the size of kl; each element of xl is a randomly sampled input.
    *)
    xl <- [];
    while (size xl < min t_dmspr (size kl)) {
      x <$ din;
      xl <- rcons xl x;
    }
    
    (* 
      Ask adversary to find a second preimage for any input
      in xl w.r.t. the corresponding (i.e., at the same index) key in kl
    *)
    (i, x') <@ A.find(xl);
    
    (* 
      Get key k and input x from kl and, respectively, xl at index i,
      as specified by the adversary 
    *)
    k <- nth witness kl i;
    x <- nth witness xl i; 
    
    (* 
      Success iff
      (1) "0 <= i < min t_dmspr (size kl)": index provided by adversary is within the allowed 
          bounds of kl (i.e., between 0 (including) and the minimum of t_dmspr and 
          size kl (excluding)), and
      (2) "uniq kl": kl contains no duplicate elements, and
      (3) "x <> x'": x is not equal to x', and
      (4) "f k x = f k x'": f k maps x' to y
    *)
    return 0 <= i < min t_dmspr (size kl) /\ uniq kl /\ x <> x' /\ f k x = f k x';
  }
}.


(* 
-- 
  Collision Resistance (CR).
  Given a key k, it is hard to find two different inputs x and x' such that f k x = f k x' 
-- 
*)
(* - regular Collision Resistance (CR) - *)
(* Class of adversaries against CR *)
module type Adv_CR = {
  proc find(k : key_t) : in_t * in_t
}.

(* CR game *)
module CR(A : Adv_CR) = {
  proc main() : bool = {
    var k : key_t;
    var x, x' : in_t;
    
    (* Sample key k *)
    k <$ dkey;

    (* Ask adversary to find two values x and x' that collide w.r.t. to k (i.e., under f k) *)
    (x, x') <@ A.find(k);
    
    (*
      Success iff
      (1) "x <> x'": x does not equal x', and
      (2) "f k x = f k x'": f k maps x to the same element as it maps x'
    *)
    return x <> x' /\ f k x = f k x'; 
  }
}.


(* - Target Collision Resistance (TCR) - *)
(* Class of adversaries against TCR *)
module type Adv_TCR = {
  proc pick() : in_t
  proc find(k : key_t) : in_t
}.

(* TCR game *)
module TCR(A : Adv_TCR) = {
  proc main() : bool = {
    var k : key_t;
    var x, x' : in_t;
    
    (* Ask adversary to pick an input (the 'target') *)
    x <@ A.pick();
    
    (* Sample key k *)
    k <$ dkey;
    
    (* Ask adversary to find a value x' that collides with x w.r.t k (i.e., under f k) *)
    x' <@ A.find(k);
    
    (*
      Success iff
      (1) "x <> x'": x does not equal x', and
      (2) "f k x = f k x'": f k maps x to the same element as it maps x'
    *) 
    return x <> x' /\ f k x = f k x';
  }
}.


(* - Extended Target Collision Resistance (ETCR) - *)
(* Class of adversaries against ETCR *)
module type Adv_ETCR = {
  proc pick() : in_t
  proc find(k : key_t) : key_t * in_t
}.

(* ETCR game *)
module ETCR (A : Adv_ETCR) = {
  proc main() : bool = {
    var k, k' : key_t;
    var x, x' : in_t;
    
    (* Ask adversary to pick an input (the 'target') *)
    x <@ A.pick();
    
    (* Sample key k *)
    k <$ dkey;
    
     (* 
       Ask adversary to find any pair (k', x') such that x under f k collides with
       x' under f k'.
       Note that k' may be any element from the domain of keys, including k
     *)
    (k', x') <@ A.find(k);
    
    (*
      Success iff
      (1) "x <> x'": x does not equal x', and
      (2) "f k x = f k' x'": f k maps x to the same element as f k' maps x'
    *) 
    return x <> x' /\ f k x = f k' x';
  }
}.


(* - Multi-target Extended Target Collision Resistance (M_ETCR) - *)
(* Number of targets in M_ETCR *)
const t_metcr : { int | 1 <= t_metcr } as ge1_tmetcr.

(* Type for oracles used in M_ETCR game *)
module type Oracle_METCR = {
  proc init() : unit
  proc query(x : in_t) : key_t
  proc get(i : int) : key_t * in_t
  proc nr_targets() : int
}.

(* Default implementation of an oracle for M_ETCR *)
module O_METCR_Default : Oracle_METCR = {
  var ts : (key_t * in_t) list
  
  (* Initialize list of targets (i.e., (key, input) pairs) to the empty list *)
  proc init() : unit = {
    ts <- [];
  }
  
  (* Samples key k, adds pair (k, x) to list of targets, and returns k *)
  proc query(x : in_t) : key_t = {
    var k : key_t;
    var kx : key_t * in_t;
    
    k <$ dkey;
    
    kx <- (k, x);
    ts <- rcons ts kx;
      
    return k;
  }
  
  (* Gets i-th element in list of targets; returns witness if index is out of bounds *)
  proc get(i : int) : key_t * in_t = {
    return nth witness ts i;
  }
  
  (* Returns the number of elements in the list of targets *)
  proc nr_targets() : int = {
    return size ts; 
  }
}.

(* Class of adversaries against M_ETCR *)
module type Adv_METCR(O : Oracle_METCR) = {
  proc find() : int * key_t * in_t { O.query }
}.

(* M_ETCR game *)
module M_ETCR (A : Adv_METCR, O : Oracle_METCR) = {
  (* Provide adversary access to oracle O *)
  module A = A(O)
  
  proc main() : bool = {
    var k, k' : key_t;
    var x, x' : in_t;
    var i : int;
    var nrts : int;
    
    (* Initialize oracle O *)
    O.init();
    
    (* 
      Ask adversary to
      (1) Generate (key, input) pairs (the 'targets') by querying oracle O
      (2) Find a pair (k', x') such that, for any (key, input) pair (k, x) in 
          the list of targets, x' under f k' collides with x under f k.
          Note that k' may be any element from the domain of keys, including k 
    *)
    (i, k', x') <@ A.find();
    
    (* 
      Get (key, input) pair (i.e., target) (k, x) from list of targets at index i,
      as specified by the adversary
    *)
    (k, x) <@ O.get(i);
    
    (* Get number of elements in the list of targets specified by the adversary *)
    nrts <@ O.nr_targets();
    
    (*
      Success iff
      (1) "1 <= nrts <= t_metcr": the list of targets has size at least 1 and at most t_metcr, 
          limiting the number of oracle calls the adversary can make, and
      (2) "0 <= i < size nrts": index provided by adversary is within the bounds 
          of nrts (i.e., between 0 (including) and nrts (excluding)), and
      (3) "x <> x'": x does not equal x', and
      (4) "f k x = f k' x'": f k maps x to the same element as f k' maps x'
    *)     
    return 1 <= nrts <= t_metcr /\ 0 <= i < nrts /\ x <> x' /\ f k x = f k' x';
  }
}.


(* 
-- 
  Decisional Second Preimage Resistance (DSPR).
  Given a key k and input x, it is hard to determine whether there exists an input x'
  that is different from x such that f k x = f k x'
--
*)
(* - General - *)
(* Predicate that checks whether there exists a second preimage for a given x under f k *)
op spexists (k : key_t, x : in_t) = exists (x' : in_t), x' <> x /\ f k x' = f k x.

 
(* - single-function, single-target Decisional Second Preimage Resistance (DSPR) - *)
(* Class of adversaries against DSPR *)
module type Adv_DSPR = {
  proc guess(k : key_t, x : in_t) : bool
}.

(* 
  Module used to denote the probability that a randomly sampled input
  has a second preimage under a randomly sampled function from the
  hash function family f.
  Denotes the probability that could trivially be obtained in the
  DSPR game by invariably returning 1
*)
module SPprob(A : Adv_DSPR) = {
  proc main() = {
    var k : key_t;
    var x : in_t;
    var b : bool;
    
    (* Sample key k and input x *)
    k <$ dkey;
    x <$ din;
    
    (* Ask adversary to determine whether x has a preimage under f k *)
    b <@ A.guess(k, x); 
    
    (* Success iff x has a second preimage under f k *)
    return spexists k x;
  }
}.

(* DSPR game *)
module DSPR(A : Adv_DSPR) = {
  proc main() : bool = {
    var k : key_t;
    var x : in_t;
    var b : bool;
    
    (* Sample key k and input x *)
    k <$ dkey;
    x <$ din;
    
    (* Ask adversary to determine whether x has a preimage under f k *)
    b <@ A.guess(k, x); 
    
    (* Success iff adversary correctly determined whether x has a second preimage under f k *)
    return spexists k x = b;
  }
}.


(* - Single-Function, Multi-Target Decisional Second Preimage Resistance (SM_DSPR) - *)
(* Number of targets in SM_DSPR *)
const t_smdspr : { int |1 <= t_smdspr } as ge1_tsmdspr.

(* Class of adversaries against SM_DSPR *)
module type Adv_SMDSPR = {
  proc guess(k : key_t, xl : in_t list) : int * bool
}.

(* 
  Module used to denote the probability that could trivially be obtained in the
  SM_DSPR game by invariably returning 1
*)
module SM_SPprob(A : Adv_SMDSPR) = {
  proc main() = {
    var k : key_t;
    var x : in_t;
    var xl : in_t list; 
    var i : int;
    var b : bool;
    
    
    (* Sample key k *)
    k <$ dkey;
    
    (* Construct list xl of t_smdspr randomly sampled inputs *)
    xl <- [];
    while (size xl < t_smdspr) {
      x <$ din;
      xl <- rcons xl x;
    }
    
    (* 
      Ask the adversary to determine, for any input in xl, 
      whether the input has a second preimage w.r.t. key k
    *)
    (i, b) <@ A.guess(k, xl); 
    
    (* Get input from xl at index i, as specified by the adversary *)
    x <- nth witness xl i;
    
    (* 
      Success iff
      (1) "0 <= i < size xl": index i provided by adversary is within the bounds of xl
          (i.e., between 0 (including) and the size xl = t_smdspr (excluding)), and
      (2) "spexists k x": adversary correctly determined whether x has a 
          second preimage under f k 
    *)
    return 0 <= i < size xl /\ spexists k x;
  }
}.

(* SM_DSPR game *)
module SM_DSPR(A : Adv_SMDSPR) = {
  proc main() = {
    var k : key_t;
    var x : in_t;
    var xl : in_t list; 
    var i : int;
    var b : bool;
    
    (* Sample key k *)
    k <$ dkey;
    
    (* Construct list xl of t_smdspr randomly sampled inputs *)
    xl <- [];
    while (size xl < t_smdspr) {
      x <$ din;
      xl <- rcons xl x;
    }
    
    (* 
      Ask the adversary to determine, for any input in xl, 
      whether the input has a second preimage w.r.t. key k
    *)
    (i, b) <@ A.guess(k, xl); 
    
    (* Get input from xl at index i, as specified by the adversary *)
    x <- nth witness xl i;
    
    (* 
      Success iff
      (1) "0 <= i < size xl": index i provided by adversary is within the bounds of xl
          (i.e., between 0 (including) and the size xl = t_smdspr (excluding)), and
      (2) "spexists k x": adversary correctly determined whether x has a 
          second preimage under f k 
    *)
    return 0 <= i < size xl /\ spexists k x = b;
  }
}.

(*
In the above:
Adv_SMDSPR(A) = max 0 (Pr[SM_DSPR(A).main() @ &m : res] - Pr[SM_SPprob.main() @ &m : res]).
*)


(* - Multi-Function, Multi-Target Decisional Second Preimage Resistance (MM_DSPR) - *)
(* Number of functions/targets in MM_DSPR *)
const t_mmdspr : { int |1 <= t_mmdspr } as ge1_tmmdspr.

(* Class of adversaries against MM_DSPR *)
module type Adv_MMDSPR = {
  proc guess(kxl : (key_t * in_t) list) : int * bool
}.

(* 
  Module used to denote the probability that could trivially be obtained in the
  MM_DSPR game by invariably returning 1
*)
module MM_SPprob(A : Adv_MMDSPR) = {
  proc main() = {
    var k : key_t;
    var x : in_t;
    var kx : key_t * in_t;
    var kxl : (key_t * in_t) list; 
    var i : int;
    var b : bool;
    
    (*
      Construct list kxl of size t_mmdspr containing (key, input) pairs (k, x).
      For each pair, key k and input x are both randomly sampled from
      their respective distributions
    *)  
    kxl <- [];
    while (size kxl < t_mmdspr) {
      k <$ dkey;
      x <$ din;
      kx <- (k, x);
      kxl <- rcons kxl kx;
    }
    
    (* 
      Ask the adversary to determine, for any (key, input) pair in kxl, 
      whether the input has a second preimage w.r.t. the key in the (same) pair
    *)
    (i, b) <@ A.guess(kxl); 
    
    (* Get (key, input) pair kx from kxl at index i, as specified by the adversary *)
    kx <- nth witness kxl i;
    
    (* Extract key k and, respectively, input x from kx *)
    k <- kx.`1;
    x <- kx.`2;
    
    (* 
      Success iff 
      (1) "0 <= i < size kxl": index i provided by adversary is within the bounds of kxl
          (i.e., between 0 (including) and the size kxl = t_mmdspr (excluding)), and
      (2) "spexists k x": x has a second preimage under f k 
    *)
    return 0 <= i < size kxl /\ spexists k x;
  }
}.

(* MM_DSPR game *)
module MM_DSPR(A : Adv_MMDSPR) = {
  proc main() : bool = {
    var k : key_t;
    var x : in_t;
    var kx : key_t * in_t;
    var kxl : (key_t * in_t) list; 
    var i : int;
    var b : bool;
    
    (*
      Construct list kxl of size t_mmdspr containing (key, input) pairs (k, x).
      For each pair, key k and input x are both randomly sampled from
      their respective distributions
    *)  
    kxl <- [];
    while (size kxl < t_mmdspr) {
      k <$ dkey;
      x <$ din;
      kx <- (k, x);
      kxl <- rcons kxl kx;
    }
    
    (* 
      Ask the adversary to determine, for any (key, input) pair in kxl,
      whether the input has a second preimage w.r.t. the key in the (same) pair
    *)
    (i, b) <@ A.guess(kxl); 
    
    (* Get (key, input) pair kx from kxl at index i, as specified by the adversary *)
    kx <- nth witness kxl i;
    
    (* Extract key k and, respectively, input x from kx *)
    k <- kx.`1;
    x <- kx.`2;
    
    (*
      Success iff 
      (1) "0 <= i < size kxl": index i provided by adversary is within the bounds of kxl
          (i.e., between 0 (including) and size kxl = t_mmdspr (excluding)), and
      (2) "spexists k x = b": adversary correctly determined whether
          x has a second preimage under f k 
    *)
    return 0 <= i < size kxl /\ spexists k x = b;
  }
}.

(*
In the above:
Adv_MMDSPR(A) = max 0 (Pr[MM_DSPR(A).main(t) @ &m : res] - Pr[MM_SPprob(A).main(t) @ &m : res])
*)


(* - Distinct-function, Multi-target Decisional Second Preimage Resistance (DM_DSPR) - *)
(* Number of functions/targets in DM_DSPR *)
const t_dmdspr : { int |1 <= t_dmdspr } as ge1_tdmdspr.

(* Class of adversaries against DM_DSPR *)
module type Adv_DMDSPR = {
  proc pick() : key_t list
  proc guess(xl : in_t list) : int * bool
}.

(* 
  Module used to denote the probability that could trivially be obtained in the
  DM_DSPR game by invariably returning 1
*)
module DM_SPprob(A : Adv_DMDSPR) = {
  proc main() = {
    var k : key_t;
    var x : in_t;
    var kl : key_t list;
    var xl : in_t list; 
    var kx : key_t * in_t;
    var i : int;
    var b : bool;
  
    (* 
      Ask adversary to provide a list kl of keys that will be used to index f.
      As indicated in the return statement, this list must not contain duplicate 
      elements (so that indexing f with each element gives a distinct function)
    *)
    kl <@ A.pick();
    
    (*
      Construct list xl of a size equal to the minimum of 
      t_dmdspr and the size of kl; each element of xl is a randomly sampled input
    *)
    xl <- [];
    while (size xl < min t_dmdspr (size kl)) {
      x <$ din;
      xl <- rcons xl x;
    }
    
    (* 
      Ask adversary to determine, for any input x in xl, whether x has a
      second preimage w.r.t. the corresponding (i.e., at the same index) key in kl
    *)
    (i, b) <@ A.guess(xl);
    
    (* 
      Get key k and input x from kl and, respectively, xl at index i,
      as specified by the adversary 
    *)
    k <- nth witness kl i;
    x <- nth witness xl i; 
    
    (* 
      Success iff
      (1) "0 <= i < min t (size kl)": index i provided by adversary is within the allowed 
          bounds of kl (i.e., between 0 (including) and the minimum of t_dmdspr 
          and size kl (excluding)), and
      (2) "uniq kl": kl contains no duplicate elements, and
      (3) "spexists k x": x has a second preimage under f k
    *)
    return 0 <= i < min t_dmdspr (size kl) /\ uniq kl /\ spexists k x;
  }
}.

(* DM_DSPR game *)
module DM_DSPR(A : Adv_DMDSPR) = {
  proc main() = {
    var k : key_t;
    var x : in_t;
    var kl : key_t list;
    var xl : in_t list; 
    var kx : key_t * in_t;
    var i : int;
    var b : bool;
  
    (* 
      Ask adversary to provide a list kl of keys that will be used to index f.
      As indicated in the return statement, this list must not contain duplicate 
      elements (so that indexing f with each element gives a distinct function)
    *)
    kl <@ A.pick();
    
    (*
      Construct list xl of a size equal to the minimum of 
      t_dmdspr and the size of kl; each element of xl is a randomly sampled input
    *)
    xl <- [];
    while (size xl < min t_dmdspr (size kl)) {
      x <$ din;
      xl <- rcons xl x;
    }
    
    (* 
      Ask adversary to determine, for any input x in xl, whether x has a
      second preimage w.r.t. the corresponding (i.e., at the same index) key in kl
    *)
    (i, b) <@ A.guess(xl);
    
    (* 
      Get key k and input x from kl and, respectively, xl at index i,
      as specified by the adversary 
    *)
    k <- nth witness kl i;
    x <- nth witness xl i; 
    
    (* 
      Success iff
      (1) "0 <= i < min t_dspr (size kl)": index i provided by adversary is within the allowed 
          bounds of kl (i.e., between 0 (including) and the minimum of t_dmdspr 
          and size kl (excluding)), and
      (2) "uniq kl": kl contains no duplicate elements, and
      (3) "spexists k x = b": adversary correctly determined whether
          x has a second preimage under f k
    *)
    return 0 <= i < min t_dmdspr (size kl) /\ uniq kl /\ spexists k x = b;
  }
}.

(*
In the above:
Adv_DMDSPR(A) = max 0 (Pr[DM_DSPR(A).main(t) @ &m : res] - Pr[DM_SPprob(A).main(t) @ &m : res])
*)


(* 
-- 
  UnDetectability (UD). 
  Given a key k and output y, it is hard to determine whether y was obtained by
  randomly sampling from the domain of outputs or by computing f k x where x is
  randomly sampled from the domain of inputs
-- 
*)
(* - single-function, single-target UnDetectability (UD) - *)
(* Class of adversaries against UD *)
module type Adv_UD = {
  proc distinguish(k : key_t, y : out_t) : bool
}.

(* UD game *)
module UD(A : Adv_UD) = {
  proc main(b : bool) : bool = {
    var k : key_t;
    var x : in_t;
    var y : out_t;
    var b' : bool;
    
    (* Sample key k *)
    k <$ dkey;
    
    (* 
      If b
      then randomly sample input x and compute output y by applying f k to x
      else randomly sample output y
    *) 
    if (b) {
      x <$ din;
      y <- f k x;
    } else {
      y <$ dout;
    }
    
    (* 
      Ask adversary to determine whether y is
      (1) computed as f k x for a randomly sampled input x, or
      (2) randomly sampled
    *)
    b' <@ A.distinguish(k, y);
    
    (* Directly return output of adversary *)
    return b';
  }
}.


(* - Single-function, Multi-target UnDetectability (SM_UD) - *)
(* Number of targets in SM_UD *)
const t_smud : { int | 1 <= t_smud } as ge1_tsmud. 

(* Class of adversaries against SM_UD *)
module type Adv_SMUD = {
  proc distinguish(k : key_t, yl : out_t list) : bool
}.

(* SM_UD game *)
module SM_UD(A : Adv_SMUD) = {
  proc main(b : bool) : bool = {
    var k : key_t;
    var x : in_t;
    var y : out_t;
    var yl : out_t list;
    var b' : bool;
    
    (* Sample key k *)
    k <$ dkey;
    
    (*
      Construct list of t_smud outputs yl, where each element y is obtained as
        If b
        then randomly sample input x and compute y by applying f k to x
        else randomly sample y
    *)
    yl <- [];
    while (size yl < t_smud) {
      if (b) {
        x <$ din;
        y <- f k x;
      } else {
        y <$ dout;
      }
      
      yl <- rcons yl y; 
    }

    (* 
      Ask adversary to determine whether the outputs in yl are
      (1) computed as f k x for a randomly sampled input x, or
      (2) randomly sampled
    *)
    b' <@ A.distinguish(k, yl);
    
    (* Directly return output of adversary *)
    return b';
  }
}.


(* - Multi-function, Multi-target UnDetectability (MM_UD) - *)
(* Number of functions/targets in MM_UD *)
const t_mmud : { int | 1 <= t_mmud } as ge1_tmmud. 

(* Class of adversaries against MM_UD *)
module type Adv_MMUD = {
  proc distinguish(kyl : (key_t * out_t) list) : bool
}.

(* MM_UD game *)
module MM_UD(A : Adv_MMUD) = {
  proc main(b : bool) : bool  = {
    var k : key_t;
    var x : in_t;
    var y : out_t;
    var ky : key_t * out_t;
    var kyl : (key_t * out_t) list;
    var b' : bool;
    
    (*
      Construct list kyl of size t_mmud containing (key, output) pairs (k, y).
      For each pair, key k is randomly sampled and output y is obtained as
        If b
        then randomly sample input x and compute y by applying f k to x
        else randomly sample y
    *)
    kyl <- [];
    while (size kyl < t_mmud) {
      k <$ dkey;
      
      if (b) {
        x <$ din;
        y <- f k x;
      } else {
        y <$ dout;
      }
      
      ky <- (k, y);
      kyl <- rcons kyl ky;
    }
    
    (* 
      Ask adversary to determine whether each (key, output) pair (k, y) in 
      in kyl is
      (1) computed as f k x for a randomly sampled input x, or
      (2) randomly sampled
    *)
    b' <@ A.distinguish(kyl);
    
    (* Directly return output of adversary *)
    return b';
  }
}.


(* - Distinct-function, Multi-target UnDetectability (DM_UD) - *)
(* Number of functions/targets in DM_UD *)
const t_dmud : { int | 1 <= t_dmud } as ge1_tdmud. 

(* Class of adversaries against DM_UD *)
module type Adv_DMUD = {
  proc pick() : key_t list
  proc distinguish(yl : out_t list) : bool
}.

(* DM_UD game *)
module DM_UD(A : Adv_DMUD) = {
  proc main(b : bool) = {
    var k : key_t;
    var x : in_t;
    var y : out_t;
    var kl : key_t list;
    var yl : out_t list;
    var i : int;
    var b' : bool;
  
    (* 
      Ask adversary to provide a list kl of keys that will be used to index f.
      As indicated in the return statement, this list must not contain duplicate 
      elements (so that indexing f with each element gives a distinct function)
    *) 
    kl <@ A.pick();
    
    (*
      Construct list yl of a size equal to the minimum of 
      t_ud and the size of kl; each element y of yl is obtained as 
        If b
        then get key k at corresponding position from kl, randomly sample input x, 
             and compute y by applying f k to x
        else randomly sample y
    *)
    yl <- [];
    while (size yl < min t_dmud (size kl)) {
      k <- nth witness kl (size yl);
      
      if (b) {
        x <$ din;
        y <- f k x;
      } else {
        y <$ dout;
      }
      
      yl <- rcons yl y;
    }
    
    (* 
      Ask adversary to determine whether each output y in yl is
      (1) computed as f k x for a randomly sampled input x
          (where k is the corresponding (i.e., at the same index) key in kl), or
      (2) randomly sampled
    *)
    b' <@ A.distinguish(yl);
    
    (* 
       Return 1 iff
       (1) "uniq kl": kl contains no duplicate elements, and
       (2) "b'": adversary returned 1 
    *)
    return uniq kl /\ b';
  }
}.


(* 
-- 
  Interleaved Target Subset Resilience (ITSR).
-- 
*)
(* 
  Types for indices pointing to (ordered) key sets, (ordered) secret value sets, 
  and, secret values, respectively 
*)
type idxks_t.
type idxsvs_t.
type idxsv_t.

(* Number of targets for ITSR *)
const t_itsr : { int | 1 <= t_itsr } as ge1_titsr.

(* Number of secret value sets in each key set *)
const svsks : { int | 1 <= svsks } as ge1_svsks.

(* Number of secret values in each secret value set *)
const svsvs : { int | 1 <= svsvs } as ge1_svsvs.

(* 
  Map from outputs of hash function to a list of tuples of the form
  (key set index, secret value set index, secret value index).
  In this list, each tuple has the same key set index
*) 
op g : out_t -> (idxks_t * idxsvs_t * idxsv_t) list.
axiom eqiks_g (x x' : idxks_t * idxsvs_t * idxsv_t) (y : out_t) : 
  x \in g y => x' \in g y => x.`1 = x'.`1.

(* Composition of g with f *)
op h (k : key_t) (x : in_t) : (idxks_t * idxsvs_t * idxsv_t) list = g (f k x).

(* Type for oracles used in ITSR game *)
module type Oracle_ITSR = {
  proc init() : unit
  proc query(x : in_t) : key_t
  proc get_targets() : (key_t * in_t) list
}.

(* Default implementation of an oracle for ITSR *)
module O_ITSR_Default : Oracle_ITSR = {
  var ts : (key_t * in_t) list
  
  (* Initialize list of targets (i.e., (key, input) pairs) to the empty list *)
  proc init() : unit = {
    ts <- [];
  }
  
  (* Samples key k, adds pair (k, x) to list of targets, and returns k *)
  proc query(x : in_t) : key_t = {
    var k : key_t;
    var kx : key_t * in_t;
    
    k <$ dkey;
   
    kx <- (k, x);
    ts <- rcons ts kx;
    
    return k;
  }
  
  (* Gets and returns list of targets ts *)
  proc get_targets() : (key_t * in_t) list = {
    return ts;
  }
}.

(* Class of adversaries against ITSR *)
module type Adv_ITSR(O : Oracle_ITSR) = {
  proc find() : key_t * in_t { O.query }
}.

(* ITSR game *)
module ITSR(A : Adv_ITSR, O : Oracle_ITSR) = {
  (* Provide adversary access to oracle O *)
  module A = A(O)
  
  proc main() : bool = {
    var k : key_t;
    var x : in_t;
    var kxl : (key_t * in_t) list;
    var ikssl_f, ikssl_q : (idxks_t * idxsvs_t * idxsv_t) list;
    
    (* Initialize oracle O *)
    O.init();
    
    (* 
      Ask adversary to
      (1) Specify (key, input) pairs (the 'targets') by querying oracle O
      (2) Find a pair (k, x) that is not in the list of specified targets and for which 
          h k x returns a list of which each element is contained within the (combined) 
          list of tuples that is obtained by mapping all of the specified targets under h. 
    *)
    (k, x) <@ A.find();
    
    (* 
      Compute list of (key set index, secret value set index, secret value index) tuples 
      by applying h to key k and message x provided by the adversary 
    *)
    ikssl_f <- h k x;
    
    (* Get the list of targets specified by the adversary *)
    kxl <@ O.get_targets();
    
    (* 
      First, construct a list for which the i-th element equals h ki xi, where
      (ki, xi) denotes the i-th element (i.e., (key, input) tuple) in list kxl.
      Note that this results in a list of lists of 
      (key set index, secret value set index, secret value index) tuples.
      Then, flatten the resulting list; that is, take the tuples from all of the 
      lists (in the list of lists) and put them (orderly) in a single list.
    *) 
    ikssl_q <- flatten (map (fun (kx : key_t * in_t) => h kx.`1 kx.`2) kxl);
    
    
    (*
      Success iff
      (1) "1 <= size kxl < t_itsr": the list of targets contains at least 1 and at most
          t_itsr targets (i.e., the adversary specified at least 1 and at most t_itsr targets), 
          and
      (2) "(forall x, x \in ikssl_f => x \in ikssl_q)": the tuples in the list obtained from
          mapping the key and input provided by the adversary under h are all contained within
          the (combined) list of tuples obtained from mapping all of the specified targets
          under h, and
      (3) "!(k, x) \in kxl": the key and input provided by the adversary is not one of the
          specified targets.
    *)
    return    1 <= size kxl < t_itsr 
           /\ (forall x, x \in ikssl_f => x \in ikssl_q) 
           /\ ! (k, x) \in kxl;
  }
}.


(* 
-- 
  Pseudo-Random Function family (PRF).
  By observing a function's outputs on chosen inputs, it is hard to 
  distinguish whether the function is a randomly sampled function from the domain
  of functions with the considered domain and co-domain, or a randomly selected
  function from the hash function family f (i.e., a f k where k is randomly sampled
  from the domain of (indexing) keys).
  Note that, in contrast to other keyed hash function properties, the PRF property 
  requires the indexing key to be secret
-- 
*)
(* Function that maps inputs of type in_t to (proper) distributions over type out_t *)
op doutm : { in_t -> out_t distr | forall x, is_lossless (doutm x) } as doutm_ll.

(* Type for oracles used in PRF game *)
module type Oracle_PRF = {
  proc init(b_init : bool) : unit
  proc query(x : in_t) : out_t
}.

(* Class of adversaries against PRF *)
module type Adv_PRF(O : Oracle_PRF) = {
  proc distinguish() : bool { O.query }
}.

(* Default implementation of an oracle for PRF *)
module O_PRF_Default : Oracle_PRF = {
  var b : bool
  var k : key_t
  var m : (in_t, out_t) fmap
  
  (*
    Initializes b to given b_init, k to randomly sampled value from dkey,
    and m to the empty map
  *)
  proc init(b_init : bool) : unit = {
    b <- b_init;
    k <$ dkey;
    m <- empty;
  }
  
  (* 
    Query the oracle on input x, returning 
       if b
       then if x is not yet in map m
            then value randomly sampled from distribution doutm x
            else value at m.[x]
       else f k x  
  *)
  proc query(x : in_t) : out_t = {
    var y : out_t;
    
    if (b) {
      if (x \notin m) {
        y <$ doutm x;
        m.[x] <- y;
      }
      y <- (oget m.[x]);
    } else {
      y <- f k x;
    }
    
    return y;
  }
}.

(* PRF game *)
module PRF(A : Adv_PRF, O : Oracle_PRF) = {
  (* Give adversary access to the oracle *)
  module A = A(O)
  
  proc main(b : bool) : bool = {
    var b' : bool;
    
    (* Initialize function used by oracle *)
    O.init(b);
    
    (* 
      Ask adversary to determine whether the function used by the oracle is
      (1) a (lazily sampled) random function with domain in_t and 
          co-domain out_t, or 
      (2) of the form f k for a randomly sampled k
    *)  
    b' <@ A.distinguish();
    
    (* Directly return output of adversary *)
    return b';
  }
}.
