(**************************************************************************)
(* File containing everything related to keyed hash functions.            *)
(* This file is based on the material from several papers.                *) 
(* More precisely, this concerns the following references:                *)
(* - "Cryptographic Hash-Function Basics: Definitions, Implications, and  *)
(*    Separations for Preimage Resistance, Second-Preimage Resistance,    *)
(*    and Collision Resistance"                                           *)
(*   DOI: 10.1007/978-3-540-25937-4_24                                    *) 
(* - "Mitigating Multi-Target Attacks in Hash-based Signatures"           *)
(*   DOI: 10.1007/978-3-662-49384-7_15                                    *)
(* - "Decisional second-preimage resistance: When does SPR imply PRE?"    *)
(*   DOI: 10.1007/978-3-030-34618-8_2                                     *)
(* - "The SPHINCS+ Signature Framework."                                  *)
(*   DOI: 10.1145/3319535.3363229                                         *)
(* - "Recovering the Tight Security Proof of SPHINCS+"                    *)
(*   DOI: 10.1007/978-3-031-22972-5_1                                     *)
(**************************************************************************)

(* --- Require/Import --- *)
(* -- Built-in (i.e, standard library) -- *)
require import AllCore StdOrder List Distr DInterval Finite SmtMap.
require (*--*) PlugAndPray.
(*---*) import RField RealOrder.



(*
---
  Preliminary Note:
  The ensuing formalizes the concept of keyed hash functions and several
  properties of such functions. For most of these properties, there are 
  several variants based on the number of considered functions and/or the number of
  considered targets. Independent of the property, these variants always deviate from the
  basic property in the same manner. Below, we describe how each of these variants differs
  from the basic property. 
  
  - single-function, single-target:
    In most cases, this is the default 'variant' of the property (i.e., the standard/basic property). 
    This considers only a single function (or, equivalently, single index key) and a single target 
    (e.g., a single input or single output) with/for which the adversary can try to break the 
    considered property.
    
  - Single-function, Multi-target (SM):
    This variant considers a single function (or, equivalently, single index key) and multiple
    targets with/for which the adversary can try to break the considered property.
  
  - Multi-function, Multi-target (MM):
    This variant considers multiple functions (or, equivalently, multiple index keys) and multiple
    targets with/for which the adversary can try to break the considered property.
    
  - Distinct-function, Multi-target (DM):
    This variant considers multiple functions (or, equivalently, multiple index keys) and multiple
    targets with/for which the adversary can try to break the considered property. Here, in contrast
    to the MM variant, the functions are required to be distinct from each other.
---
*)



(* --- General --- *)
(* -- Types -- *)
(* Types for inputs ('messages') and, respectively, outputs ('message digests') of hash function *)
type in_t.
type out_t.

(* Type for (indexing) keys *)
type key_t. 


(* -- Operators -- *)
(* Keyed hash function *)
op f : key_t -> in_t -> out_t.



(* --- Properties --- *)
(* 
-- 
  PREimage resistance (PRE) / One-Wayness (OW).
  Given a key k and an output y, it is hard to find an input x such that f k x = y
-- 
*)
(* - single-function, single-target PREimage resistance (PRE) - *)
abstract theory PRE.
  (* Proper distribution over input type *)
  op [lossless] din : in_t distr.

  (* Proper distribution over (indexing) key type *)
  op [lossless] dkey : key_t distr.

  (* Class of adversaries against PRE *) 
  module type Adv_PRE = {
    proc find(k : key_t, y : out_t) : in_t
  }.

  (* PRE game *)
  module PRE(A : Adv_PRE) = {
    proc main() : bool = {
      var k : key_t;
      var x, x' : in_t;
      var y : out_t;

      (* Sample key k and input x *)
      k <$ dkey;
      x <$ din;

      (* Compute output y of hash function when given key k and input x *)
      y <- f k x;

      (* Ask adversary to find a preimage x' of y *)
      x' <@ A.find(k, y);

      (* Success iff x' is a preimage of y, i.e., if f k maps x' to y *)
      return f k x' = y;
    }
  }.
end PRE.


(* - Single-function, Multi-target PREimage resistance (SM_PRE) - *)
abstract theory SMPRE.
  (* Number of targets in SM_PRE *)
  const t_smpre : { int | 1 <= t_smpre } as ge1_tsmpre.

  (* Proper distribution over input type *)
  op [lossless] din : in_t distr.

  (* Proper distribution over (indexing) key type *)
  op [lossless] dkey : key_t distr.
  
  (* Class of adversaries against SM_PRE *) 
  module type Adv_SMPRE = {
    proc find(k : key_t, yl : out_t list) : int * in_t
  }.

  (* SM_PRE game *)
  module SM_PRE(A : Adv_SMPRE) = {
    proc main() : bool = {
      var k : key_t;
      var x, x' : in_t;
      var y : out_t;
      var yl : out_t list;
      var i : int;

      (* Sample key k *)
      k <$ dkey;

      (* 
        Construct list yl of size t_smpre containing outputs obtained
        by applying f k to randomly sampled inputs
      *)
      yl <- [];
      while (size yl < t_smpre) {
        x <$ din;
        y <- f k x;
        yl <- rcons yl y;  
      }

      (* Ask adversary to find a preimage x' of any output in yl *)
      (i, x') <@ A.find(k, yl);

      (* Get key k and output y from yl at index i, as specified by the adversary *)
      y <- nth witness yl i;

      (* 
        Success iff 
        (1) "0 <= i < size yl": index i provided by adversary is within the bounds of yl
            (i.e., between 0 (including) and the size yl = t_smpre (excluding)), and
        (2) "f k x' = y": x' is a preimage of y under f k
      *)
      return 0 <= i < size yl /\ f k x' = y;
    }
  }.
end SMPRE.


(* - Multi-function, Multi-target PREimage resistance (MM_PRE) - *)
abstract theory MMPRE.
  (* Number of functions/targets in MM_PRE *)
  const t_mmpre : { int | 1 <= t_mmpre } as ge1_tmmpre.
  
  (* Proper distribution over input type *)
  op [lossless] din : in_t distr.

  (* Proper distribution over (indexing) key type *)
  op [lossless] dkey : key_t distr.
  
  (* Class of adversaries against MM_PRE *) 
  module type Adv_MMPRE = {
    proc find(kyl : (key_t * out_t) list) : int * in_t
  }.

  (* MM_PRE game *)
  module MM_PRE(A : Adv_MMPRE) = {
    proc main() : bool = {
      var k : key_t;
      var x, x' : in_t;
      var y : out_t;
      var ky : key_t * out_t;
      var kyl : (key_t * out_t) list;
      var i : int;

      (*
        Construct list kyl of t_mmpre (key, output) pairs (k, y).
        For each pair, key k is randomly sampled, 
        after which output y is obtained by applying f k
        to a randomly sampled input            
      *)
      kyl <- [];
      while (size kyl < t_mmpre) {
        k <$ dkey;
        x <$ din;
        y <- f k x;
        ky <- (k, y);
        kyl <- rcons kyl ky;
      }

      (* 
        Ask adversary to find a preimage of an output in any 
        (key, output) pair in kyl w.r.t. the key in the (same) pair 
      *)
      (i, x') <@ A.find(kyl);

      (* Get (key, output) pair ky from kyl at index i, as specified by adversary *)
      ky <- nth witness kyl i;

      (* Extract key k and, respecively, output y from ky *)
      k <- ky.`1;
      y <- ky.`2;

      (* 
        Success iff 
        (1) "0 <= i < size kyl": index provided by adversary is within the bounds of kyl 
            (i.e., between 0 (including) and size kyl = t_mmpre (excluding)), and
        (2) "f k x' = y": f k maps x' to y 
      *)
      return 0 <= i < size kyl /\ f k x' = y;
    }
  }.
end MMPRE.


(* - Distinct-function, Multi-target PREimage resistance (DM_PRE) - *)
abstract theory DMPRE.
  (* Proper distribution over input type *)
  op [lossless] din : in_t distr.

  (* Class of adversaries against DM_PRE *) 
  module type Adv_DMPRE = {
    proc pick() : key_t list
    proc find(yl : out_t list) : int * in_t
  }.

  (* DM_PRE game *)
  module DM_PRE(A : Adv_DMPRE) = {
    proc main() : bool = {
      var k : key_t;
      var x, x' : in_t;
      var y : out_t;
      var kl : key_t list;
      var yl : out_t list;
      var i : int;

      (* 
        Ask adversary to provide a list kl of keys that will be used to index f.
        As indicated in the return statement, this list must not contain duplicate 
        elements (so that indexing f with each element gives a distinct function)
      *) 
      kl <@ A.pick();

      (*
        Construct list yl of a size equal to the size of kl.
        In yl, the element at index i is the mapping of a randomly sampled input 
        under the function obtained fromindexing f with the element of kl at index i.
        That is, if the i-th element of kl is k, then the i-th element of 
        yl is obtained by applying f k to a randomly sampled input
      *)
      yl <- [];
      while (size yl < size kl) {
        k <- nth witness kl (size yl);
        x <$ din;
        y <- f k x;
        yl <- rcons yl y;
      }

      (* 
        Ask adversary to find a preimage for any output
        in yl w.r.t. the corresponding  (i.e., at the same index) key in kl
      *)
      (i, x') <@ A.find(yl);

      (* 
        Get key k and output y from kl and, respectively, yl at index i, 
        as specified by the adversary 
      *)
      k <- nth witness kl i;
      y <- nth witness yl i; 

      (* 
        Success iff
        (1) "0 <= i < size kl": index provided by adversary is within the bounds of kl, and
        (2) "uniq kl": kl contains no duplicate elements, and
        (3) "f k x' = y": f k maps x' to y
      *)
      return 0 <= i < size kl /\ uniq kl /\ f k x' = y;
    }
  }.
end DMPRE.


(* 
-- 
  Second Preimage Resistance (SPR).
  Given a key k and input x, it is hard to find an input x' that is different from x
  such that f k x = f k x'
-- 
*)
(* - single-function, single-target Second Preimage Resistance (SPR) - *)
abstract theory SPR.
  (* Proper distribution over input type *)
  op [lossless] din : in_t distr.

  (* Proper distribution over (indexing) key type *)
  op [lossless] dkey : key_t distr.
  
  (* Class of adversaries against SPR *) 
  module type Adv_SPR = {
    proc find(k : key_t, x : in_t) : in_t
  }.

  (* SPR game *)
  module SPR(A : Adv_SPR) = {
    proc main() : bool  = {
      var k : key_t;
      var x, x' : in_t;

      (* Sample key k and input x *)
      k <$ dkey;
      x <$ din;

      (* Ask adversary to find a second preimage x' of x w.r.t. k (i.e., under f k) *)
      x' <@ A.find(k, x);

      (* 
        Success iff
        (1) "x <> x'": x does not equal x', and
        (2) "f k x = f k x'": f k maps x to the same element as it maps x'
      *)
      return x <> x' /\ f k x = f k x';
    }
  }.
end SPR.


(* - Single-function, Multi-target Second Preimage Resistance (SM_SPR) - *)
abstract theory SMSPR.
  (* Number of targets in SM_SPR *)
  const t_smspr : { int | 1 <= t_smspr } as ge1_tsmspr.
  
  (* Proper distribution over input type *)
  op [lossless] din : in_t distr.

  (* Proper distribution over (indexing) key type *)
  op [lossless] dkey : key_t distr.
  
  (* Class of adversaries against SM_SPR *)
  module type Adv_SMSPR = {
    proc find(k : key_t, xl : in_t list) : int * in_t
  }.

  (* SM_SPR game *)
  module SM_SPR(A : Adv_SMSPR) = {
    proc main() : bool  = {
      var k : key_t;
      var x, x' : in_t;
      var xl : in_t list;
      var i : int;

      (* Sample key k *)
      k <$ dkey;

      (* Construct list xl of t_smspr randomly sampled inputs *)
      xl <- [];
      while (size xl < t_smspr) {
        x <$ din;
        xl <- rcons xl x;
      }

      (* Ask adversary to find second preimage for any input in xl *)
      (i, x') <@ A.find(k, xl);

      (* Get input from xl at index i, as specified by the adversary *)
      x <- nth witness xl i;

      (* 
        Success iff
        (1) "0 <= i < size xl": index i provided by adversary is within the bounds of xl
            (i.e., between 0 (including) and the size xl = t_smspr (excluding)), and
        (2) "x <> x'": x does not equal x'
        (3) "f k x = f k x'": f k maps x to the same element as it maps x'  
      *)
      return 0 <= i < size xl /\ x <> x' /\ f k x = f k x';
    }
  }.
end SMSPR.


(* - Multi-function, Multi-target Second Preimage Resistance (MM_SPR) - *)
abstract theory MMSPR.
  (* Number of functions/targets in MM_SPR *)
  const t_mmspr : { int | 1 <= t_mmspr } as ge1_tmmspr.
  
  (* Proper distribution over input type *)
  op [lossless] din : in_t distr.
  
  (* Proper distribution over (indexing) key type *)
  op [lossless] dkey : key_t distr.
  
  (* Class of adversaries against MM_SPR *)
  module type Adv_MMSPR = {
    proc find(kxl : (key_t * in_t) list) : int * in_t
  }.

  (* MM_SPR game *)
  module MM_SPR(A : Adv_MMSPR) = {
    proc main() : bool  = {
      var k : key_t;
      var x, x' : in_t;
      var kx : key_t * in_t;
      var kxl : (key_t * in_t) list;
      var i : int;

      (*
        Construct list kxl of size t_mmspr containing (key, input) pairs (k, x).
        For each pair, key k and input x are both randomly sampled from
        their respective distributions
      *)
      kxl <- [];
      while (size kxl < t_mmspr) {
        k <$ dkey;
        x <$ din;
        kx <- (k, x);
        kxl <- rcons kxl kx;
      }

      (* 
        Ask adversary to find a second preimage for an input in any
        (key, input) pair in kxl w.r.t. the key in the (same) pair   
      *)
      (i, x') <@ A.find(kxl);

      (* Get (key, input) pair kx from kxl at index i, as specified by the adversary *)
      kx <- nth witness kxl i;

      (* Extract key k and, respectively, input x from kx *)
      k <- kx.`1;
      x <- kx.`2;

      (*
        Success iff
        (1) "0 <= i < size kxl": index provided by adversary is within the bounds of kyl 
            (i.e., between 0 (including) and size kxl = t_mmspr (excluding)), and
        (2) "x <> x'": x does not equal x', and
        (3) "f k x = f k x'": f k maps x to the same element as it maps x'
      *)
      return 0 <= i < size kxl /\ x <> x' /\ f k x = f k x';
    }
  }.
end MMSPR.


(* - Distinct-function, Multi-target Second Preimage Resistance (DM_SPR) - *)
abstract theory DMSPR.
  (* Proper distribution over input type *)
  op [lossless] din : in_t distr.

  (* Class of adversaries against DM_SPR *)
  module type Adv_DMSPR = {
    proc pick() : key_t list
    proc find(xl : in_t list) : int * in_t
  }.

  (* DM_SPR game *)
  module DM_SPR(A : Adv_DMSPR) = {
    proc main() : bool = {
      var k : key_t;
      var x, x' : in_t;
      var kl : key_t list;
      var xl : in_t list;
      var i : int;

      (* 
        Ask adversary to provide a list kl of keys that will be used to index f.
        As indicated in the return statement, this list must not contain duplicate 
        elements (so that indexing f with each element gives a distinct function)
      *)
      kl <@ A.pick();

      (*
        Construct list xl of a size equal to the size of kl; 
        each element of xl is a randomly sampled input.
      *)
      xl <- [];
      while (size xl < size kl) {
        x <$ din;
        xl <- rcons xl x;
      }

      (* 
        Ask adversary to find a second preimage for any input
        in xl w.r.t. the corresponding (i.e., at the same index) key in kl
      *)
      (i, x') <@ A.find(xl);

      (* 
        Get key k and input x from kl and, respectively, xl at index i,
        as specified by the adversary 
      *)
      k <- nth witness kl i;
      x <- nth witness xl i; 

      (* 
        Success iff
        (1) "0 <= i < size kl": index provided by adversary is within the bounds of kl, and
        (2) "uniq kl": kl contains no duplicate elements, and
        (3) "x <> x'": x is not equal to x', and
        (4) "f k x = f k x'": f k maps x' to y
      *)
      return 0 <= i < size kl /\ uniq kl /\ x <> x' /\ f k x = f k x';
    }
  }.
end DMSPR.


(* 
-- 
  Collision Resistance (CR).
  Given a key k, it is hard to find two different inputs x and x' such that f k x = f k x' 
-- 
*)
(* - regular Collision Resistance (CR) - *)
abstract theory CR.
  (* Proper distribution over (indexing) key type *)
  op [lossless] dkey : key_t distr.

  (* Class of adversaries against CR *)
  module type Adv_CR = {
    proc find(k : key_t) : in_t * in_t
  }.

  (* CR game *)
  module CR(A : Adv_CR) = {
    proc main() : bool = {
      var k : key_t;
      var x, x' : in_t;

      (* Sample key k *)
      k <$ dkey;

      (* Ask adversary to find two values x and x' that collide w.r.t. to k (i.e., under f k) *)
      (x, x') <@ A.find(k);

      (*
        Success iff
        (1) "x <> x'": x does not equal x', and
        (2) "f k x = f k x'": f k maps x to the same element as it maps x'
      *)
      return x <> x' /\ f k x = f k x'; 
    }
  }.
end CR.


(* - Target Collision Resistance (TCR) - *)
abstract theory TCR.
  (* Proper distribution over (indexing) key type *)
  op [lossless] dkey : key_t distr.

  (* Class of adversaries against TCR *)
  module type Adv_TCR = {
    proc pick() : in_t
    proc find(k : key_t) : in_t
  }.

  (* TCR game *)
  module TCR(A : Adv_TCR) = {
    proc main() : bool = {
      var k : key_t;
      var x, x' : in_t;

      (* Ask adversary to pick an input (the 'target') *)
      x <@ A.pick();

      (* Sample key k *)
      k <$ dkey;

      (* Ask adversary to find a value x' that collides with x w.r.t k (i.e., under f k) *)
      x' <@ A.find(k);

      (*
        Success iff
        (1) "x <> x'": x does not equal x', and
        (2) "f k x = f k x'": f k maps x to the same element as it maps x'
      *) 
      return x <> x' /\ f k x = f k x';
    }
  }.
end TCR.


(* - Extended Target Collision Resistance (ETCR) - *)
abstract theory ETCR.
  (* Proper distribution over (indexing) key type *)
  op [lossless] dkey : key_t distr.

  (* Class of adversaries against ETCR *)
  module type Adv_ETCR = {
    proc pick() : in_t
    proc find(k : key_t) : key_t * in_t
  }.

  (* ETCR game *)
  module ETCR (A : Adv_ETCR) = {
    proc main() : bool = {
      var k, k' : key_t;
      var x, x' : in_t;

      (* Ask adversary to pick an input (the 'target') *)
      x <@ A.pick();

      (* Sample key k *)
      k <$ dkey;

       (* 
         Ask adversary to find any pair (k', x') such that x under f k collides with
         x' under f k'.
         Note that k' may be any element from the domain of keys, including k
       *)
      (k', x') <@ A.find(k);

      (*
        Success iff
        (1) "x <> x'": x does not equal x', and
        (2) "f k x = f k' x'": f k maps x to the same element as f k' maps x'
      *) 
      return x <> x' /\ f k x = f k' x';
    }
  }.
end ETCR.


(* - Multi-target Extended Target Collision Resistance (M_ETCR) - *)
abstract theory METCR.
  (* Proper distribution over (indexing) key type *)
  op [lossless] dkey : key_t distr.

  (* Type for oracles used in M_ETCR game *)
  module type Oracle_METCR = {
    proc init() : unit
    proc query(x : in_t) : key_t
    proc get(i : int) : key_t * in_t
    proc nr_targets() : int
  }.

  (* Default implementation of an oracle for M_ETCR *)
  module O_METCR_Default : Oracle_METCR = {
    var ts : (key_t * in_t) list

    (* Initialize list of targets (i.e., (key, input) pairs) to the empty list *)
    proc init() : unit = {
      ts <- [];
    }

    (* Samples key k, adds pair (k, x) to list of targets, and returns k *)
    proc query(x : in_t) : key_t = {
      var k : key_t;
      var kx : key_t * in_t;

      k <$ dkey;

      kx <- (k, x);
      ts <- rcons ts kx;

      return k;
    }

    (* Gets i-th element in list of targets; returns witness if index is out of bounds *)
    proc get(i : int) : key_t * in_t = {
      return nth witness ts i;
    }

    (* Returns the number of elements in the list of targets *)
    proc nr_targets() : int = {
      return size ts; 
    }
  }.

  (* Class of adversaries against M_ETCR *)
  module type Adv_METCR(O : Oracle_METCR) = {
    proc find() : int * key_t * in_t { O.query }
  }.

  (* M_ETCR game *)
  module M_ETCR (A : Adv_METCR, O : Oracle_METCR) = {
    proc main() : bool = {
      var k, k' : key_t;
      var x, x' : in_t;
      var i : int;
      var nrts : int;

      (* Initialize oracle O *)
      O.init();

      (* 
        Ask adversary to
        (1) Generate (key, input) pairs (the 'targets') by querying oracle O
        (2) Find a pair (k', x') such that, for any (key, input) pair (k, x) in 
            the list of targets, x' under f k' collides with x under f k.
            Note that k' may be any element from the domain of keys, including k 
      *)
      (i, k', x') <@ A(O).find();

      (* 
        Get (key, input) pair (i.e., target) (k, x) from list of targets at index i,
        as specified by the adversary
      *)
      (k, x) <@ O.get(i);

      (* Get number of elements in the list of targets specified by the adversary *)
      nrts <@ O.nr_targets();

      (*
        Success iff
        (1) "0 <= i < size nrts": index provided by adversary is within the bounds 
            of nrts (i.e., between 0 (including) and nrts (excluding)), and
        (2) "x <> x'": x does not equal x', and
        (3) "f k x = f k' x'": f k maps x to the same element as f k' maps x'
      *)     
      return 0 <= i < nrts /\ x <> x' /\ f k x = f k' x';
    }
  }.
end METCR.


(* 
-- 
  Decisional Second Preimage Resistance (DSPR).
  Given a key k and input x, it is hard to determine whether there exists an input x'
  that is different from x such that f k x = f k x'
--
*)
(* - General - *)
(* Predicate that checks whether there exists a second preimage for a given x under f k *)
abbrev spexists (k : key_t, x : in_t) = exists (x' : in_t), x' <> x /\ f k x' = f k x.

 
(* - single-function, single-target Decisional Second Preimage Resistance (DSPR) - *)
abstract theory DSPR.
  (* Proper distribution over input type *)
  op [lossless] din : in_t distr.

  (* Proper distribution over (indexing) key type *)
  op [lossless] dkey : key_t distr.

  (* Class of adversaries against DSPR *)
  module type Adv_DSPR = {
    proc guess(k : key_t, x : in_t) : bool
  }.

  (* 
    Module used to denote the probability that a randomly sampled input
    has a second preimage under a randomly sampled function from the
    hash function family f.
    Denotes the probability that could trivially be obtained in the
    DSPR game by invariably returning 1
  *)
  module SPprob(A : Adv_DSPR) = {
    proc main() = {
      var k : key_t;
      var x : in_t;
      var b : bool;

      (* Sample key k and input x *)
      k <$ dkey;
      x <$ din;

      (* Ask adversary to determine whether x has a preimage under f k *)
      b <@ A.guess(k, x); 

      (* Success iff x has a second preimage under f k *)
      return spexists k x;
    }
  }.

  (* DSPR game *)
  module DSPR(A : Adv_DSPR) = {
    proc main() : bool = {
      var k : key_t;
      var x : in_t;
      var b : bool;

      (* Sample key k and input x *)
      k <$ dkey;
      x <$ din;

      (* Ask adversary to determine whether x has a preimage under f k *)
      b <@ A.guess(k, x); 

      (* Success iff adversary correctly determined whether x has a second preimage under f k *)
      return spexists k x = b;
    }
  }.
end DSPR.


(* - Single-Function, Multi-Target Decisional Second Preimage Resistance (SM_DSPR) - *)
abstract theory SMDSPR.
  (* Number of targets in SM_DSPR *)
  const t_smdspr : { int | 1 <= t_smdspr } as ge1_tsmdspr.

  (* Proper distribution over input type *)
  op [lossless] din : in_t distr.

  (* Proper distribution over (indexing) key type *)
  op [lossless] dkey : key_t distr.
  
  (* Class of adversaries against SM_DSPR *)
  module type Adv_SMDSPR = {
    proc guess(k : key_t, xl : in_t list) : int * bool
  }.

  (* 
    Module used to denote the probability that could trivially be obtained in the
    SM_DSPR game by invariably returning 1
  *)
  module SM_SPprob(A : Adv_SMDSPR) = {
    proc main() = {
      var k : key_t;
      var x : in_t;
      var xl : in_t list; 
      var i : int;
      var b : bool;


      (* Sample key k *)
      k <$ dkey;

      (* Construct list xl of t_smdspr randomly sampled inputs *)
      xl <- [];
      while (size xl < t_smdspr) {
        x <$ din;
        xl <- rcons xl x;
      }

      (* 
        Ask the adversary to determine, for any input in xl, 
        whether the input has a second preimage w.r.t. key k
      *)
      (i, b) <@ A.guess(k, xl); 

      (* Get input from xl at index i, as specified by the adversary *)
      x <- nth witness xl i;

      (* 
        Success iff
        (1) "0 <= i < size xl": index i provided by adversary is within the bounds of xl
            (i.e., between 0 (including) and the size xl = t_smdspr (excluding)), and
        (2) "spexists k x": adversary correctly determined whether x has a 
            second preimage under f k 
      *)
      return 0 <= i < size xl /\ spexists k x;
    }
  }.

  (* SM_DSPR game *)
  module SM_DSPR(A : Adv_SMDSPR) = {
    proc main() = {
      var k : key_t;
      var x : in_t;
      var xl : in_t list; 
      var i : int;
      var b : bool;

      (* Sample key k *)
      k <$ dkey;

      (* Construct list xl of t_smdspr randomly sampled inputs *)
      xl <- [];
      while (size xl < t_smdspr) {
        x <$ din;
        xl <- rcons xl x;
      }

      (* 
        Ask the adversary to determine, for any input in xl, 
        whether the input has a second preimage w.r.t. key k
      *)
      (i, b) <@ A.guess(k, xl); 

      (* Get input from xl at index i, as specified by the adversary *)
      x <- nth witness xl i;

      (* 
        Success iff
        (1) "0 <= i < size xl": index i provided by adversary is within the bounds of xl
            (i.e., between 0 (including) and the size xl = t_smdspr (excluding)), and
        (2) "spexists k x": adversary correctly determined whether x has a 
            second preimage under f k 
      *)
      return 0 <= i < size xl /\ spexists k x = b;
    }
  }.

  (*
    In the above:
    Adv_SMDSPR(A) = max 0 (Pr[SM_DSPR(A).main() @ &m : res] - Pr[SM_SPprob.main() @ &m : res]).
  *)
end SMDSPR.


(* - Multi-Function, Multi-Target Decisional Second Preimage Resistance (MM_DSPR) - *)
abstract theory MMDSPR.
  (* Number of functions/targets in MM_DSPR *)
  const t_mmdspr : { int | 1 <= t_mmdspr } as ge1_tmmdspr.
  
  (* Proper distribution over input type *)
  op [lossless] din : in_t distr.

  (* Proper distribution over (indexing) key type *)
  op [lossless] dkey : key_t distr.

  (* Class of adversaries against MM_DSPR *)
  module type Adv_MMDSPR = {
    proc guess(kxl : (key_t * in_t) list) : int * bool
  }.

  (* 
    Module used to denote the probability that could trivially be obtained in the
    MM_DSPR game by invariably returning 1
  *)
  module MM_SPprob(A : Adv_MMDSPR) = {
    proc main() = {
      var k : key_t;
      var x : in_t;
      var kx : key_t * in_t;
      var kxl : (key_t * in_t) list; 
      var i : int;
      var b : bool;

      (*
        Construct list kxl of size t_mmdspr containing (key, input) pairs (k, x).
        For each pair, key k and input x are both randomly sampled from
        their respective distributions
      *)  
      kxl <- [];
      while (size kxl < t_mmdspr) {
        k <$ dkey;
        x <$ din;
        kx <- (k, x);
        kxl <- rcons kxl kx;
      }

      (* 
        Ask the adversary to determine, for any (key, input) pair in kxl, 
        whether the input has a second preimage w.r.t. the key in the (same) pair
      *)
      (i, b) <@ A.guess(kxl); 

      (* Get (key, input) pair kx from kxl at index i, as specified by the adversary *)
      kx <- nth witness kxl i;

      (* Extract key k and, respectively, input x from kx *)
      k <- kx.`1;
      x <- kx.`2;

      (* 
        Success iff 
        (1) "0 <= i < size kxl": index i provided by adversary is within the bounds of kxl
            (i.e., between 0 (including) and the size kxl = t_mmdspr (excluding)), and
        (2) "spexists k x": x has a second preimage under f k 
      *)
      return 0 <= i < size kxl /\ spexists k x;
    }
  }.

  (* MM_DSPR game *)
  module MM_DSPR(A : Adv_MMDSPR) = {
    proc main() : bool = {
      var k : key_t;
      var x : in_t;
      var kx : key_t * in_t;
      var kxl : (key_t * in_t) list; 
      var i : int;
      var b : bool;

      (*
        Construct list kxl of size t_mmdspr containing (key, input) pairs (k, x).
        For each pair, key k and input x are both randomly sampled from
        their respective distributions
      *)  
      kxl <- [];
      while (size kxl < t_mmdspr) {
        k <$ dkey;
        x <$ din;
        kx <- (k, x);
        kxl <- rcons kxl kx;
      }

      (* 
        Ask the adversary to determine, for any (key, input) pair in kxl,
        whether the input has a second preimage w.r.t. the key in the (same) pair
      *)
      (i, b) <@ A.guess(kxl); 

      (* Get (key, input) pair kx from kxl at index i, as specified by the adversary *)
      kx <- nth witness kxl i;

      (* Extract key k and, respectively, input x from kx *)
      k <- kx.`1;
      x <- kx.`2;

      (*
        Success iff 
        (1) "0 <= i < size kxl": index i provided by adversary is within the bounds of kxl
            (i.e., between 0 (including) and size kxl = t_mmdspr (excluding)), and
        (2) "spexists k x = b": adversary correctly determined whether
            x has a second preimage under f k 
      *)
      return 0 <= i < size kxl /\ spexists k x = b;
    }
  }.

  (*
    In the above:
    Adv_MMDSPR(A) = max 0 (Pr[MM_DSPR(A).main(t) @ &m : res] - Pr[MM_SPprob(A).main(t) @ &m : res])
  *)
end MMDSPR.


(* - Distinct-function, Multi-target Decisional Second Preimage Resistance (DM_DSPR) - *)
abstract theory DMDSPR.
  (* Proper distribution over input type *)
  op [lossless] din : in_t distr.
  
  (* Class of adversaries against DM_DSPR *)
  module type Adv_DMDSPR = {
    proc pick() : key_t list
    proc guess(xl : in_t list) : int * bool
  }.

  (* 
    Module used to denote the probability that could trivially be obtained in the
    DM_DSPR game by invariably returning 1
  *)
  module DM_SPprob(A : Adv_DMDSPR) = {
    proc main() = {
      var k : key_t;
      var x : in_t;
      var kl : key_t list;
      var xl : in_t list; 
      var kx : key_t * in_t;
      var i : int;
      var b : bool;

      (* 
        Ask adversary to provide a list kl of keys that will be used to index f.
        As indicated in the return statement, this list must not contain duplicate 
        elements (so that indexing f with each element gives a distinct function)
      *)
      kl <@ A.pick();

      (*
        Construct list xl of a size equal to the size of kl; 
        each element of xl is a randomly sampled input
      *)
      xl <- [];
      while (size xl < size kl) {
        x <$ din;
        xl <- rcons xl x;
      }

      (* 
        Ask adversary to determine, for any input x in xl, whether x has a
        second preimage w.r.t. the corresponding (i.e., at the same index) key in kl
      *)
      (i, b) <@ A.guess(xl);

      (* 
        Get key k and input x from kl and, respectively, xl at index i,
        as specified by the adversary 
      *)
      k <- nth witness kl i;
      x <- nth witness xl i; 

      (* 
        Success iff
        (1) "0 <= i < size kl": index provided by adversary is within the bounds of kl, and
        (2) "uniq kl": kl contains no duplicate elements, and
        (3) "spexists k x": x has a second preimage under f k
      *)
      return 0 <= i < size kl /\ uniq kl /\ spexists k x;
    }
  }.

  (* DM_DSPR game *)
  module DM_DSPR(A : Adv_DMDSPR) = {
    proc main() = {
      var k : key_t;
      var x : in_t;
      var kl : key_t list;
      var xl : in_t list; 
      var kx : key_t * in_t;
      var i : int;
      var b : bool;

      (* 
        Ask adversary to provide a list kl of keys that will be used to index f.
        As indicated in the return statement, this list must not contain duplicate 
        elements (so that indexing f with each element gives a distinct function)
      *)
      kl <@ A.pick();

      (*
        Construct list xl of a size equal to the size of kl; 
        each element of xl is a randomly sampled input
      *)
      xl <- [];
      while (size xl < size kl) {
        x <$ din;
        xl <- rcons xl x;
      }

      (* 
        Ask adversary to determine, for any input x in xl, whether x has a
        second preimage w.r.t. the corresponding (i.e., at the same index) key in kl
      *)
      (i, b) <@ A.guess(xl);

      (* 
        Get key k and input x from kl and, respectively, xl at index i,
        as specified by the adversary 
      *)
      k <- nth witness kl i;
      x <- nth witness xl i; 

      (* 
        Success iff
        (1) "0 <= i < size kl": index provided by adversary is within the bounds of kl, and
        (2) "uniq kl": kl contains no duplicate elements, and
        (3) "spexists k x = b": adversary correctly determined whether
            x has a second preimage under f k
      *)
      return 0 <= i < size kl /\ uniq kl /\ spexists k x = b;
    }
  }.

  (*
    In the above:
    Adv_DMDSPR(A) = max 0 (Pr[DM_DSPR(A).main(t) @ &m : res] - Pr[DM_SPprob(A).main(t) @ &m : res])
  *)
end DMDSPR.


(* 
-- 
  UnDetectability (UD). 
  Given a key k and output y, it is hard to determine whether y was obtained by
  randomly sampling from the domain of outputs or by computing f k x where x is
  randomly sampled from the domain of inputs
-- 
*)
(* - single-function, single-target UnDetectability (UD) - *)
abstract theory UD.
  (* Proper distribution over input type *)
  op [lossless] din : in_t distr.

  (* Proper distribution over output type *)
  op [lossless] dout : out_t distr.
  
  (* Proper distribution over (indexing) key type *)
  op [lossless] dkey : key_t distr.

  (* Class of adversaries against UD *)
  module type Adv_UD = {
    proc distinguish(k : key_t, y : out_t) : bool
  }.

  (* UD game *)
  module UD(A : Adv_UD) = {
    proc main(b : bool) : bool = {
      var k : key_t;
      var x : in_t;
      var y : out_t;
      var b' : bool;

      (* Sample key k *)
      k <$ dkey;

      (* 
        If b
        then randomly sample input x and compute output y by applying f k to x
        else randomly sample output y
      *) 
      if (b) {
        x <$ din;
        y <- f k x;
      } else {
        y <$ dout;
      }

      (* 
        Ask adversary to determine whether y is
        (1) computed as f k x for a randomly sampled input x, or
        (2) randomly sampled
      *)
      b' <@ A.distinguish(k, y);

      (* Directly return output of adversary *)
      return b';
    }
  }.
end UD.


(* - Single-function, Multi-target UnDetectability (SM_UD) - *)
abstract theory SMUD.
  (* Number of targets in SM_UD *)
  const t_smud : { int | 1 <= t_smud } as ge1_tsmud. 

  (* Proper distribution over input type *)
  op [lossless] din : in_t distr.

  (* Proper distribution over output type *)
  op [lossless] dout : out_t distr.
  
  (* Proper distribution over (indexing) key type *)
  op [lossless] dkey : key_t distr.
    
  (* Class of adversaries against SM_UD *)
  module type Adv_SMUD = {
    proc distinguish(k : key_t, yl : out_t list) : bool
  }.

  (* SM_UD game *)
  module SM_UD(A : Adv_SMUD) = {
    proc main(b : bool) : bool = {
      var k : key_t;
      var x : in_t;
      var y : out_t;
      var yl : out_t list;
      var b' : bool;

      (* Sample key k *)
      k <$ dkey;

      (*
        Construct list of t_smud outputs yl, where each element y is obtained as
          If b
          then randomly sample input x and compute y by applying f k to x
          else randomly sample y
      *)
      yl <- [];
      while (size yl < t_smud) {
        if (b) {
          x <$ din;
          y <- f k x;
        } else {
          y <$ dout;
        }

        yl <- rcons yl y; 
      }

      (* 
        Ask adversary to determine whether the outputs in yl are
        (1) computed as f k x for a randomly sampled input x, or
        (2) randomly sampled
      *)
      b' <@ A.distinguish(k, yl);

      (* Directly return output of adversary *)
      return b';
    }
  }.
end SMUD.


(* - Multi-function, Multi-target UnDetectability (MM_UD) - *)
abstract theory MMUD.
  (* Number of functions/targets in MM_UD *)
  const t_mmud : { int | 1 <= t_mmud } as ge1_tmmud. 

  (* Proper distribution over input type *)
  op [lossless] din : in_t distr.

  (* Proper distribution over output type *)
  op [lossless] dout : out_t distr.
  
  (* Proper distribution over (indexing) key type *)
  op [lossless] dkey : key_t distr.

  (* Class of adversaries against MM_UD *)
  module type Adv_MMUD = {
    proc distinguish(kyl : (key_t * out_t) list) : bool
  }.

  (* MM_UD game *)
  module MM_UD(A : Adv_MMUD) = {
    proc main(b : bool) : bool  = {
      var k : key_t;
      var x : in_t;
      var y : out_t;
      var ky : key_t * out_t;
      var kyl : (key_t * out_t) list;
      var b' : bool;

      (*
        Construct list kyl of size t_mmud containing (key, output) pairs (k, y).
        For each pair, key k is randomly sampled and output y is obtained as
          If b
          then randomly sample input x and compute y by applying f k to x
          else randomly sample y
      *)
      kyl <- [];
      while (size kyl < t_mmud) {
        k <$ dkey;

        if (b) {
          x <$ din;
          y <- f k x;
        } else {
          y <$ dout;
        }

        ky <- (k, y);
        kyl <- rcons kyl ky;
      }

      (* 
        Ask adversary to determine whether each (key, output) pair (k, y) in 
        in kyl is
        (1) computed as f k x for a randomly sampled input x, or
        (2) randomly sampled
      *)
      b' <@ A.distinguish(kyl);

      (* Directly return output of adversary *)
      return b';
    }
  }.
end MMUD.


(* - Distinct-function, Multi-target UnDetectability (DM_UD) - *)
abstract theory DMUD.
  (* Proper distribution over input type *)
  op [lossless] din : in_t distr.

  (* Proper distribution over output type *)
  op [lossless] dout : out_t distr.
  
  (* Proper distribution over (indexing) key type *)
  op [lossless] dkey : key_t distr.

  (* Class of adversaries against DM_UD *)
  module type Adv_DMUD = {
    proc pick() : key_t list
    proc distinguish(yl : out_t list) : bool
  }.

  (* DM_UD game *)
  module DM_UD(A : Adv_DMUD) = {
    proc main(b : bool) = {
      var k : key_t;
      var x : in_t;
      var y : out_t;
      var kl : key_t list;
      var yl : out_t list;
      var i : int;
      var b' : bool;

      (* 
        Ask adversary to provide a list kl of keys that will be used to index f.
        As indicated in the return statement, this list must not contain duplicate 
        elements (so that indexing f with each element gives a distinct function)
      *) 
      kl <@ A.pick();

      (*
        Construct list yl of a size equal to the size of kl;
        each element y of yl is obtained as 
          If b
          then get key k at corresponding position from kl, randomly sample input x, 
               and compute y by applying f k to x
          else randomly sample y
      *)
      yl <- [];
      while (size yl < size kl) {
        k <- nth witness kl (size yl);

        if (b) {
          x <$ din;
          y <- f k x;
        } else {
          y <$ dout;
        }

        yl <- rcons yl y;
      }

      (* 
        Ask adversary to determine whether each output y in yl is
        (1) computed as f k x for a randomly sampled input x
            (where k is the corresponding (i.e., at the same index) key in kl), or
        (2) randomly sampled
      *)
      b' <@ A.distinguish(yl);

      (* 
         Return 1 iff
         (1) "uniq kl": kl contains no duplicate elements, and
         (2) "b'": adversary returned 1 
      *)
      return uniq kl /\ b';
    }
  }.
end DMUD.


(* 
-- 
  Interleaved Target Subset Resilience (ITSR).
-- 
*)
abstract theory ITSR.
  (* Number of secret value sets in each key set *)
  const svsks : { int | 1 <= svsks } as ge1_svsks.

  (* Number of secret values in each secret value set *)
  const svsvs : { int | 1 <= svsvs } as ge1_svsvs.

  (* 
    Types for indices pointing to (ordered) key sets, (ordered) secret value sets, 
    and, secret values, respectively 
  *)
  type idxks_t.
  type idxsvs_t.
  type idxsv_t.

  (* Proper distribution over (indexing) key type *)
  op [lossless] dkey : key_t distr.

  (* 
    Map from outputs of hash function to a list of tuples of the form
    (key set index, secret value set index, secret value index).
    For this list, the following holds.
    - Its size is equal to the number of secret value sets (i.e., svsvs).
    - Each tuple it contains has the same key set index.
    - Each tuple it contains has a different secret value set index.
  *) 
  op g : out_t -> (idxks_t * idxsvs_t * idxsv_t) list.
  axiom size_g (y : out_t) : 
    size (g y) = svsvs.
  axiom eqiks_g (x x' : idxks_t * idxsvs_t * idxsv_t) (y : out_t) : 
    x \in g y => x' \in g y => x.`1 = x'.`1.
  axiom neqisvs_g (x x' : idxks_t * idxsvs_t * idxsv_t) (y : out_t) : 
    x \in g y => x' \in g y => x <> x' => x.`2 <> x'.`2.
    
  (* Composition of g with f *)
  op h (k : key_t) (x : in_t) : (idxks_t * idxsvs_t * idxsv_t) list = g (f k x).

  (* Type for oracles used in ITSR game *)
  module type Oracle_ITSR = {
    proc init() : unit
    proc query(x : in_t) : key_t
    proc get_targets() : (key_t * in_t) list
  }.

  (* Default implementation of an oracle for ITSR *)
  module O_ITSR_Default : Oracle_ITSR = {
    var ts : (key_t * in_t) list

    (* Initialize list of targets (i.e., (key, input) pairs) to the empty list *)
    proc init() : unit = {
      ts <- [];
    }

    (* Samples key k, adds pair (k, x) to list of targets, and returns k *)
    proc query(x : in_t) : key_t = {
      var k : key_t;
      var kx : key_t * in_t;

      k <$ dkey;

      kx <- (k, x);
      ts <- rcons ts kx;

      return k;
    }

    (* Gets and returns list of targets ts *)
    proc get_targets() : (key_t * in_t) list = {
      return ts;
    }
  }.

  (* Class of adversaries against ITSR *)
  module type Adv_ITSR(O : Oracle_ITSR) = {
    proc find() : key_t * in_t { O.query }
  }.

  (* ITSR game *)
  module ITSR(A : Adv_ITSR, O : Oracle_ITSR) = {
    proc main() : bool = {
      var k : key_t;
      var x : in_t;
      var kxl : (key_t * in_t) list;
      var ikssl_f, ikssl_q : (idxks_t * idxsvs_t * idxsv_t) list;

      (* Initialize oracle O *)
      O.init();

      (* 
        Ask adversary to
        (1) Specify (key, input) pairs (the 'targets') by querying oracle O
        (2) Find a pair (k, x) that is not in the list of specified targets and for which 
            h k x returns a list of which each element is contained within the (combined) 
            list of tuples that is obtained by mapping all of the specified targets under h. 
      *)
      (k, x) <@ A(O).find();

      (* 
        Compute list of (key set index, secret value set index, secret value index) tuples 
        by applying h to key k and message x provided by the adversary 
      *)
      ikssl_f <- h k x;

      (* Get the list of targets specified by the adversary *)
      kxl <@ O.get_targets();

      (* 
        First, construct a list for which the i-th element equals h ki xi, where
        (ki, xi) denotes the i-th element (i.e., (key, input) tuple) in list kxl.
        Note that this results in a list of lists of 
        (key set index, secret value set index, secret value index) tuples.
        Then, flatten the resulting list; that is, take the tuples from all of the 
        lists (in the list of lists) and put them (orderly) in a single list.
      *) 
      ikssl_q <- flatten (map (fun (kx : key_t * in_t) => h kx.`1 kx.`2) kxl);


      (*
        Success iff
        (1) "(forall x, x \in ikssl_f => x \in ikssl_q)": the tuples in the list obtained 
            from mapping the key and input provided by the adversary under h are all 
            contained within the (combined) list of tuples obtained from mapping all of 
            the specified targets under h, and
        (2) "! (k, x) \in kxl": the key and input provided by the adversary is not one 
            of the specified targets.
      *)
      return (forall x, x \in ikssl_f => x \in ikssl_q) /\ ! (k, x) \in kxl;
    }
  }.
end ITSR.


(* 
-- 
  Pseudo-Random Function family (PRF).
  By observing a function's outputs on chosen inputs, it is hard to 
  distinguish whether the function is a randomly sampled function from the domain
  of functions with the considered domain and co-domain, or a randomly selected
  function from the hash function family f (i.e., a f k where k is randomly sampled
  from the domain of (indexing) keys).
  Note that, in contrast to other keyed hash function properties, the PRF property 
  requires the indexing key to be secret
-- 
*)
abstract theory PRF.
  (* Proper distribution over (indexing) key type *)
  op [lossless] dkey : key_t distr.

  (* Function that maps inputs of type in_t to (proper) distributions over type out_t *)
  op doutm : { in_t -> out_t distr | forall x, is_lossless (doutm x) } as doutm_ll.

  (* Type for oracles used in PRF game *)
  module type Oracle_PRF = {
    proc init(b_init : bool) : unit
    proc query(x : in_t) : out_t
  }.

  (* Class of adversaries against PRF *)
  module type Adv_PRF(O : Oracle_PRF) = {
    proc distinguish() : bool { O.query }
  }.

  (* Default implementation of an oracle for PRF *)
  module O_PRF_Default : Oracle_PRF = {
    var b : bool
    var k : key_t
    var m : (in_t, out_t) fmap

    (*
      Initializes b to given b_init, k to randomly sampled value from dkey,
      and m to the empty map
    *)
    proc init(b_init : bool) : unit = {
      b <- b_init;
      k <$ dkey;
      m <- empty;
    }

    (* 
      Query the oracle on input x, returning 
         if b
         then if x is not yet in map m
              then value randomly sampled from distribution doutm x
              else value at m.[x]
         else f k x  
    *)
    proc query(x : in_t) : out_t = {
      var y : out_t;

      if (b) {
        if (x \notin m) {
          y <$ doutm x;
          m.[x] <- y;
        }
        y <- (oget m.[x]);
      } else {
        y <- f k x;
      }

      return y;
    }
  }.

  (* PRF game *)
  module PRF(A : Adv_PRF, O : Oracle_PRF) = {
    proc main(b : bool) : bool = {
      var b' : bool;

      (* Initialize function used by oracle *)
      O.init(b);

      (* 
        Ask adversary to determine whether the function used by the oracle is
        (1) a random function with domain in_t and co-domain out_t, or 
        (2) of the form f k for a randomly sampled k
      *)  
      b' <@ A(O).distinguish();

      (* Directly return output of adversary *)
      return b';
    }
  }.
end PRF.
